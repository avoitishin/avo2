--[[
	Copyright (C) 2012 Alundaio
	This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
-]]
function add_stalker(npc)
	if not (db.OnlineStalkers) then
		db.OnlineStalkers = {}
	end
	for i=#db.OnlineStalkers,1,-1 do
		if (npc:id() == db.OnlineStalkers[i]) then
			return
		end
	end
	table.insert(db.OnlineStalkers,npc:id())
end

function del_stalker(npc)
	if not (db.OnlineStalkers) then
		return
	end
	for i=#db.OnlineStalkers,1,-1 do
		if (npc:id() == db.OnlineStalkers[i]) then
			table.remove(db.OnlineStalkers,i)
			break
		end
	end
end

function release_object(p)
	local sim = alife()
	local se_obj = p[1] and sim:object(p[1])
	if not (se_obj) then
		return true
	end

	if (se_obj.online) then
		se_obj:switch_offline()
		return false
	end

	alun_utils.printf("safe released %s",se_obj:name())
	sim:release(se_obj,true)

	return true
end

-- Prints a formated lua table to print_table.txt for debugging purposes
function print_table(tbl,header)
	local txt = tostring(header) .. "\n{\n\n"
	local depth = 1

	local function tab(amt)
		local str = ""
		for i=1,amt, 1 do
			str = str .. "\t"
		end
		return str
	end

	local function table_to_string(tbl)
		local size = 0
		for k,v in pairs(tbl) do
			size = size + 1
		end

		local key
		local i = 1

		for k,v in pairs(tbl) do
			if (type(k) == "number") then
				key = "[" .. k .. "]"
			else
				key = "[\""..tostring(k) .. "\"]"
			end

			if (type(v) == "table") then
				txt = txt .. tab(depth) .. key .. " =\n"..tab(depth).."{\n"
				depth = depth + 1
				table_to_string(v,tab(depth))
				depth = depth - 1
				txt = txt .. tab(depth) .. "}"
			elseif (type(v) == "number" or type(v) == "boolean") then
				txt = txt .. tab(depth) .. key .. " = " .. tostring(v)
			elseif (type(v) == "userdata") then
				txt = txt .. tab(depth) .. key .. " = \"userdata\""
			else
				txt = txt .. tab(depth) .. key .. " = \"" .. tostring(v) .. "\""
			end

			if (i == size) then
				txt = txt .. "\n"
			else
				txt = txt .. ",\n"
			end

			i = i + 1
		end
	end

	table_to_string(tbl)

	txt = txt .. "\n}"

	local file = io.open("print_table.txt","a+")
	file:write(txt.."\n\n")
	file:close()
	printf("Table written to print_table.txt")
end


function is_in_same_squad(obj,npc)
	local squad1 = get_object_squad(obj)
	local squad2 = get_object_squad(npc)
	if ( squad1 and squad2 ) then
		if ( squad1.id == squad2.id ) then
			return true
		end
	end
	return false
end

function read_from_ini(ini,section,line,var_type,default,caller)
	if not (ini) then
		ini = system_ini()
	end

	if (section and line and ini:section_exist(section) and ini:line_exist(section,line)) then
		if (var_type == "bool") then
			return ini:r_bool(section,line)
		elseif (var_type == "string") then
			return ini:r_string(section,line)
		elseif (var_type == "float") then
			return ini:r_float(section,line)
		else
			return ini:r_string_wq(section,line)
		end
	else
		return default
	end
end

function trim(s)
	return string.gsub(s, "^%s*(.-)%s*$", "%1")
end

function string:split(pat)
	pat = pat or '%s+'
	local st, g = 1, self:gmatch("()("..pat..")")
	local function getter(self, segs, seps, sep, cap1, ...)
		st = sep and seps + #sep
		return self:sub(segs, (seps or 0) - 1), cap1 or sep, ...
	end
	local function splitter(self)
		if st then return getter(self, st, g()) end
	end
	return splitter, self
end

function str_explode(str,pattern)
	local t = {}
	if (type(str) ~= "string") then return end
	for word, pat, start in str:split(pattern) do
		t[#t+1] = trim(word)
		if (start and pat == pattern) then
		    t[#t+1] = trim(str:sub(start))
			break
		end
	end
	return t
end

function hex2string(str)
    return (str:gsub('..', function (cc)
        return string.char(tonumber(cc, 16))
    end))
end

function string2hex(str)
    return (str:gsub('.', function (c)
        return string.format('%02X', string.byte(c))
    end))
end

function float2hex (n)
    if n == 0.0 then return 0.0 end

    local sign = 0
    if n < 0.0 then
        sign = 0x80
        n = -n
    end

    local mant, expo = math.frexp(n)
    local hext = {}

    if mant ~= mant then
        hext[#hext+1] = string.char(0xFF, 0x88, 0x00, 0x00)

    elseif mant == math.huge or expo > 0x80 then
        if sign == 0 then
            hext[#hext+1] = string.char(0x7F, 0x80, 0x00, 0x00)
        else
            hext[#hext+1] = string.char(0xFF, 0x80, 0x00, 0x00)
        end

    elseif (mant == 0.0 and expo == 0) or expo < -0x7E then
        hext[#hext+1] = string.char(sign, 0x00, 0x00, 0x00)

    else
        expo = expo + 0x7E
        mant = (mant * 2.0 - 1.0) * math.ldexp(0.5, 24)
        hext[#hext+1] = string.char(sign + math.floor(expo / 0x2),
                                    (expo % 0x2) * 0x80 + math.floor(mant / 0x10000),
                                    math.floor(mant / 0x100) % 0x100,
                                    mant % 0x100)
    end

    return tonumber(string.gsub(table.concat(hext),"(.)",
                                function (c) return string.format("%02X%s",string.byte(c),"") end), 16)
end


function hex2float (c)
    if c == 0 then return 0.0 end
    local c = string.gsub(string.format("%X", c),"(..)",function (x) return string.char(tonumber(x, 16)) end)
    local b1,b2,b3,b4 = string.byte(c, 1, 4)
    local sign = b1 > 0x7F
    local expo = (b1 % 0x80) * 0x2 + math.floor(b2 / 0x80)
    local mant = ((b2 % 0x80) * 0x100 + b3) * 0x100 + b4

    if sign then
        sign = -1
    else
        sign = 1
    end

    local n

    if mant == 0 and expo == 0 then
        n = sign * 0.0
    elseif expo == 0xFF then
        if mant == 0 then
            n = sign * math.huge
        else
            n = 0.0/0.0
        end
    else
        n = sign * math.ldexp(1.0 + mant / 0x800000, expo - 0x7F)
    end

    return n
end

function parse_list(ini,key,val,convert)
	local str = read_from_ini(ini,key,val,"string","")
	local t = str and str ~= "" and str_explode(str,",")
	if not (t) then
		return
	end
	if (convert and #t > 0) then
		local l = {}
		for i,v in ipairs(t) do
			l[v] = true
		end
		return l
	end
	return t
end

function eval_condlist(npc, condlist, p)
	return xr_logic.pick_section_from_condlist(db.actor,npc, condlist, p)
end

function parse_condlist(str)
	if not (str) then
		printf("alun_utils.parse_condlist: Error no source string")
		return
	end

	local src = str_explode(str,",")
	local t = {}
	local a,b,infop_check_lst,infop_set_lst,remainings,new_sect
	for i=1,#src do
		a, b, infop_check_lst = string.find(src[i], "{%s*(.*)%s*}")
		if (infop_check_lst) then
			remainings = string.sub(src[i], 1, a - 1) .. string.sub(src[i], b + 1)
		else
			remainings = src[i]
		end

		a, b, infop_set_lst = string.find(remainings, "%%%s*(.*)%s*%%")
		if (infop_set_lst) then
			new_sect = string.sub(remainings, 1, a - 1) .. string.sub(remainings, b + 1)
		else
			new_sect = remainings
		end

		new_sect = trim(new_sect)

		t[i] = {}
		t[i].infop_check = {}
		t[i].infop_set = {}

		t[i].section = new_sect
		xr_logic.parse_infop(t[i].infop_check, infop_check_lst)
		xr_logic.parse_infop(t[i].infop_set, infop_set_lst)
	end
	return t
end

function collect_sections(ini,sections)
	local r,p = {},{}
	for k,v in ipairs(sections) do
		if ini:section_exist(v) then
			local n = ini:line_count(v)
			if n > 0 then
				for i = 0,n-1 do
					local res,id,val = ini:r_line(v,i,"","")
					if r[id] == nil then
						r[id] = val
					end
				end
			end
			p[k] = n
		else
			p[k] = 0
		end
	end
	return r,p
end

local ranks
function get_rank_list()
	if ranks then
		return ranks
	end
	local tmp = parse_list(nil,"game_relations","rating")
	ranks = {}
	for i,rn in ipairs(tmp) do
		if not tonumber(rn) then
			table.insert(ranks,rn)
		end
	end
	return ranks
end


local communities
function get_communities_list()
	if communities then
		return communities
	end
	local tmp = parse_list(nil,"game_relations","communities")
	communities = {}
	for i,cn in ipairs(tmp) do
		if not tonumber(cn) then
			table.insert(communities,cn)
		end
	end
	return communities
end

function execute_script_on_squad(obj,script_to_execute,...)
	local squad = get_object_squad(obj)

	if not ( squad ) then
		script_to_execute(obj,...)
		return
	end

	for k in squad:squad_members() do
		local member = db.storage[k.id] and db.storage[k.id].object

		if ( member and member:alive() ) then
			script_to_execute(member,...)
		end
	end
end


function execute_script_on_squad_not_commander(obj,script_to_execute,...)
	local squad = get_object_squad(obj)

	if not ( squad ) then
		script_to_execute(obj,...)
		return
	end

	for k in squad:squad_members() do
		local member = db.storage[k.id] and db.storage[k.id].object

		if ( member and member:alive() and member:id() ~= squad:commander_id() ) then
			script_to_execute(member,...)
		end
	end
end

function nearest_object(match)
	local dist
	local nearest
	local min_dist
	local is_match
	for i=1, 65535 do
		local obj = alife():object(i)
		if (obj) then
			is_match = false
			if (type(match) == "string" and string.find(obj:section_name(),match)) then
				is_match = true
			elseif (type(match) == "number" and match == obj:clsid()) then
				is_match = true
			end

			if (is_match) then
				dist = obj.position:distance_to(db.actor:position())

				if not(min_dist) then
					min_dist = dist
					nearest = obj
				elseif (dist < min_dist) then
					min_dist = dist
					nearest = obj
				end
			end
		end
	end

	if (nearest) then
		if (simulation_objects.is_on_the_same_level(nearest, alife():actor()) and min_dist <= alife():switch_distance()^2) then
			return nearest,min_dist
		end
	end
end

-- level object only

function get_nearest_stalker(npc)
	if not (db.OnlineStalkers) then
		return
	end
	local stalker
	local dist
	local nearest_stalker,nearest_dist
	local pos
	local st
	for i=1, #db.OnlineStalkers do
		st = db.storage[db.OnlineStalkers[i]]
		stalker = st and st.object or level.object_by_id(db.OnlineStalkers[i])
		if (stalker and stalker:alive()) then
			pos = npc == "cam" and device().cam_pos or npc:position()
			dist = pos:distance_to_sqr(stalker:position())
			if not (nearest_dist) then
				nearest_dist = dist
				nearest_stalker = stalker
			end

			if (dist < nearest_dist) then
				nearest_dist = dist
				nearest_stalker = stalker
			end
		end
	end
	return nearest_stalker,nearest_dist
end

function get_nearest_object(npc,...)
	local p = {...}
	local match
	local lowest_dist = p[2]
	for key, value in pairs(p[1]) do
		local obj
		if ( value.object ) then
			obj = value.object
		else
			obj = value
		end
		if ( obj and obj.position ) then
			dist = npc:position():distance_to_sqr(obj:position())

			if ( dist < lowest_dist ) then
				lowest_dist = dist
				match = obj
			end
		end
	end

	if ( match ) then
		return match,lowest_dist
	end
end

function get_squad_count(npc)
	local squad = get_object_squad(npc)

	if not ( squad ) then
		return 1
	end
	local c = 0
	for k in squad:squad_members() do
		c = c + 1
	end
	return c
end

function safe_release(p)
	local sim = alife()
	local se_obj = p[1] and sim:object(p[1])
	if not (se_obj) then
		return true
	end

	-- wait for it to switch offline
	if (se_obj.online) then
		--se_obj:switch_offline()
		sim:set_switch_online(p[1],false)
		sim:set_switch_offline(p[1],true)
		return false
	end

	-- release stalker
	sim:release(se_obj,true)

	return true
end

function release(se_obj)
	if (se_obj) then
		local sim = alife()
		sim:release(se_obj,true)
	end
end

function create(p)
	--printf("section=%s position=%s lvid=%s gvid=%s",p[1],vector_to_string(p[2]),p[3],p[4])
	alife():create(p[1],p[2],p[3],p[4])
end

function get_current_action_id(npc)
	local mgr = npc:motivation_action_manager()

	if not mgr:initialized() then
		return false
	end

	return mgr:current_action_id()
end

function item_is_fa(o,c)
	if not c then
		c = o and o:clsid()
	end
	local t = {
	[clsid.wpn_pm_s] = true,
	[clsid.wpn_walther_s] = true,
	[clsid.wpn_usp45_s] = true,
	[clsid.wpn_hpsa_s] = true,
	[clsid.wpn_bm16_s] = true,
	[clsid.wpn_shotgun_s] = true,
	[clsid.wpn_auto_shotgun_s] = true,
	[clsid.wpn_ak74_s] = true,
	[clsid.wpn_lr300_s] = true,
	[clsid.wpn_groza_s] = true,
	[clsid.wpn_val_s] = true,
	[clsid.wpn_vintorez_s] = true,
	[clsid.wpn_svu_s] = true,
	[clsid.wpn_svd_s] = true,
	[clsid.wpn_rg6_s] = true,
	[clsid.wpn_rpg7_s] = true,
	[clsid.wpn_knife_s] = true}
	if c and t[c] then
		return true
	end
	return false
end

function item_is_outfit(o,c)
	if not c then
		c = o and o:clsid()
	end
	local t = {
	[clsid.equ_stalker_s] = true}
	if c and t[c] then
		return true
	end
	return false
end

function item_is_explosive(o,c)
	if not c then
		c = o and o:clsid()
	end
	local t = {
	[clsid.obj_explosive_s] = true}
	if c and t[c] then
		return true
	end
	return false
end

function is_actor(object,c)
	if not (c) then
		c = object and object:clsid()
	end
	return c == clsid.script_actor or c == clsid.actor or c == clsid.spectator or object and object:id() == db.actor:id()
end

function add_anim(npc,anim)
	if anim then
		npc:add_animation(anim,true,false)
	end
end

function get_sound(snd)
	if snd then
		return sound_object(snd)
	end
end

function safe_bone_pos(npc,bone)
    if not (npc) then
    printf("safe_bone_pos: npc is nil!")
    return
    end

  local pos

  --[[
  local cls = npc:clsid()
  if (cls == clsid.burer_s) then
    pos = utils.vector_copy_by_val(npc:position())
    pos.y = pos.y + 1
  elseif cls == clsid.gigant_s then
    pos = npc:bone_position("bip01_spine")
  else
  --]]

  if (IsStalker(npc)) then
    pos = npc:bone_position(bone or "bip01_spine")
  end

  if not (pos) then
    pos = utils.vector_copy_by_val(npc:position())
    pos.y = pos.y + 1
  end

  return pos
end
--------------------------------------switch---------------------------------------
function switch_online(id)
	if id == -1 then return end
	local sim = alife()
	if sim then
		sim:set_switch_online(id,true)
		sim:set_switch_offline(id,false)
	end
end

function switch_offline(id)
	local sim = alife()
	if sim then
		sim:set_switch_online(id,false)
		sim:set_switch_offline(id,true)
	end
end

-------------------
function angle_diff(a1, a2)
  local b1=a1:normalize()
  local b2=a2:normalize()
  local dotp=b1:dotproduct(b2)
  return utils.rad2deg(math.acos(dotp))
end

-------------------------------------------------------- DEBUG FUNCTION -------------------------------------------------
function printf(text,...)
	debug_write(text,...)
	--get_console():execute("flush")
end

function debug_write(text,...)
	if not (text) then return end
	local i = 0
	local p = {...}
	local function sr(a)
		i = i + 1
		if (type(p[1]) == "userdata") then
			return "userdata"
		end
		return tostring(p[i])
	end
	local output = string.gsub(text,"%%s",sr)
	get_console():execute("load ~#I#:"..output)
end

function str_format(str,...)
	if not (str) then
		return
	end
	local p = {...}
	local rep
	local new_str = ""
	for k,v in pairs(p) do
		rep = str_explode(v,"=")

		if (rep[1] and rep[2]) then
			str = str:gsub("("..tostring(rep[1])..")",tostring(rep[2]))
		end
	end
	return str
end

function is_trader(...)
	local p = {...}
	if p[1]:character_community() == "trader" or p[1]:clsid() == clsid.script_trader or p[1]:clsid() == clsid.trader then
		return true
	end

	if string.find(p[1]:section(),"trader") then
		return true
	end

	local cini = db.storage[p[1]:id()].ini
	local logic = db.storage[p[1]:id()].section_logic

	if not logic and not trader then
		return false
	end

	if cini and logic and cini:section_exist(logic) and cini:line_exist(logic,"trade") then
		return true
	end

	return false
end

function string_to_vector(str)
	local t = alun_utils.str_explode(str,",")
	return vector():set(tonumber(t[1]),tonumber(t[2]),tonumber(t[3]))
end

function vector_to_string(vec)
	return vec.x..","..vec.y..","..vec.z
end

function print_packet_data(data)
	local msg = ""
	for kk, vv in pairs(data) do
		if (type(vv) == "userdata" and vv.x and vv.y and vv.z) then
			--m.debug_write("%s: vector:= %s",kk,vec_to_str(vv))
			printf("%s: vector:= %s",kk,vec_to_str(vv))
			msg = msg.."["..kk.."] = "..vector_to_string(vv)
		else
			--m.debug_write("[%s] = %s",kk,vv)
			printf("[%s] = %s",kk,vv)
		end
	end
end

function set_squad_relation(npc,target,rel)
	if not (npc) then
		return
	end

	local squad = get_object_squad(npc)
	if not ( squad ) then
		return
	end

	for k in squad:squad_members() do
		local member = db.storage[k.id] and db.storage[k.id].object
		if ( member and member:alive() ) then
			member:set_relation(rel,target)
		end
	end
end

function set_squad_relation_to_squad(npc,target,rel)
	if not (npc) then
		return
	end

	local squad = get_object_squad(npc)
	if not ( squad ) then
		return
	end

	for k in squad:squad_members() do
		local member = db.storage[k.id] and db.storage[k.id].object
		if ( member and member:alive() ) then
			set_squad_relation(target,member,rel)
			set_squad_relation(member,target,rel)
		end
	end
end

function rand_num(a,b)
	local rnd = math.random
	if (a and b) then
		return rnd(a,b)
	end
	return rnd()
end

function create_squad(section,smart)
	local sim = sim_board.get_sim_board()
	if not (sim) then return end
	if not (sim.smarts_by_names[smart]) then return end
	return sim:create_squad(sim.smarts_by_names[smart],section)
end

function assign_squad_to_smart(squad_id, id)
	local sim = sim_board.get_sim_board()
	if not (sim) then return end
	local squad = alife():object(squad_id)
	if not (squad) then return end
	if (squad.smart_id) then
		sim:exit_smart(squad,squad.smart_id)
	end
	sim:assign_squad_to_smart(squad,id)
	sim:enter_smart(squad,id)
	squad.assigned_target_id = id
	squad.current_action = nil
	squad:get_next_action(false)
end

function get_commander(npc)
	local squad = npc and get_object_squad(npc)
	if (squad and squad:commander_id()) then
		return level.object_by_id(squad:commander_id())
	end
end

function get_squad_commander_action(npc)
	local commander = get_commander(npc)
	local mgr = commander and commander:motivation_action_manager()
	if (mgr and mgr:initialized()) then
		return mgr:current_action_id()
	end
end

function collect_section(ini,section,keytable)
	if not (ini) then
		return
	end

	local _t = {}
	if ini:section_exist(section) then
		local n = ini:line_count(section)
		if n > 0 then
			for i = 0,n-1 do
				local res,id,val = ini:r_line(section,i,"","")
				if (keytable) then
					if (val == "") then
						val = true
					end
					_t[id] = val or true
				else
					table.insert(_t,id)
				end
			end
		end
	end
	return _t
end

function get_vertex(npc,dist)
	local rnd1,ang = math.random(100)
	if rnd1 < 43 then
		ang = math.random(50,60)
	elseif rnd1 < 58 then
		ang = math.random(160,200)
	else
		ang = math.random(300,310)
	end
	local dir = vector_rotate_y(npc:direction(),ang)
	return npc:vertex_in_direction(npc:level_vertex_id(),dir,dist)
end

function squad_in_los(npc)
	local squad = get_object_squad(npc)
	if not (squad) then
		return
	end

	local be = npc:best_enemy()
	if not (be) then
		return
	end

	local pos = npc:bone_position("bip01_l_finger02")
	local be_pos = alun_utils.safe_bone_pos(be,"bip01_spine")
	local dir_aim = be_pos:sub(pos)

	local be_dist = npc:position():distance_to(be:position())

	for o in squad:squad_members() do
		local member = db.storage[o.id] and db.storage[o.id].object
		if (member and member:alive()) then
			local member_pos = alun_utils.safe_bone_pos(member,"bip01_spine")
			local member_dist = pos:distance_to(member_pos)-0.5
			if (member_dist < be_dist) then
				local dir_member = utils.vector_copy_by_val(member_pos):sub(pos)
				local vec_be,vec_who = utils.vector_copy_by_val(dir_aim):set_length(member_dist),dir_member:set_length(member_dist)
				local er = 1
				if (member_dist < 1.6) then
					er = 0
				end
				local mywho = vec_who:similar(vec_be,er)
				if (mywho == 1) then
					return true
				end
			end
		end
	end
end

class "fake_squad"
function fake_squad:__init(se_obj)
	local squad = se_obj.parent_id ~= 65535 and alife():object(se_obj.parent_id)
	self.id = squad and squad.id or se_obj.id
	self.player_id = squad and squad.player_id
end

function fake_squad:am_i_reached(target)

end

function fake_squad:on_reach_target(squad)

end

function fake_squad:on_after_reach_target(squad)

end

function fake_squad:target_precondition(target)
	local squad_params = target.player_id and sim_board.simulation_activities[target.player_id]
	if squad_params == nil or squad_params.squad == nil then
		return false
	end

	local squad = alife():object(self.id)
	local self_params = squad_params.squad[self.player_id]
	if self_params == nil or self_params.prec(target, squad) == false then
		return false
	end
	return true
end


function npc_in_cover(npc)
	local st = get_storage(npc:id(),"in_cover")
	local tg = time_global()
	if (st.wait or 0) < tg then
		st.wait = tg+300
		local be = npc:best_enemy()
		local enemies = {}
		if be and not xr_wounded.is_wounded(be) then
			enemies[1] = be
		else
--			rx_ai.printf("npc_in_cover[%s]:not be",npc:character_name())
			st.evn = true
			return st.evn
		end
		if IsMonster(be) then
			local bee = be:get_enemy()
			if bee and bee:id() == npc:id() then
				st.evn = false
				return st.evn
			end
		end
		local tt = {}
		for o in npc:memory_visible_objects() do
			local obj = o:object()
			local id = obj:id()
			if obj and obj:alive() and npc:relation(obj) == game_object.enemy and (IsStalker(obj) or IsMonster(obj) or obj:id() == 0) and not xr_wounded.is_wounded(obj) then
--				rx_ai.printf("npc_in_cover[%s]:add enemy[%s]",npc:character_name(),obj:name())
				table.insert(enemies,obj)
				tt[id] = true
			end
		end
		for o in npc:memory_sound_objects() do
			local obj = o:object()
			local id = obj:id()
			if not tt[id] then
				if obj and obj:alive() and npc:relation(obj) == game_object.enemy and (IsStalker(obj) or IsMonster(obj) or obj:id() == 0) and not xr_wounded.is_wounded(obj) then
--					rx_ai.printf("npc_in_cover[%s]:add enemy[%s]",npc:character_name(),obj:name())
					table.insert(enemies,obj)
				end
			end
		end
		for i,enemy in ipairs(enemies) do
			local dist = npc:position():distance_to_sqr(enemy:position())
			local seez = enemy:see(npc) or npc:see(enemy)
			local dir,cover = enemy:position():sub(npc:position())
			if npc:body_state() == move.crouch then
				 cover = level.low_cover_in_direction(npc:level_vertex_id(),dir)
			else
				 cover = level.high_cover_in_direction(npc:level_vertex_id(),dir)
			end
			if dist < 25 or (seez and (dist < 80 or cover > 0.4 or (cover > 0.2 and dist < 600))) then
--				rx_ai.printf("npc_in_cover[%s]:enemy![dist = %s,seez = %s,cover = %s]",npc:character_name(),dist,tostring(seez),cover)
				st.evn = false
				st.wait = tg+2000
				return st.evn
			end
		end
		st.evn = true
	end
	return st.evn
end

--------------------------------------addons---------------------------------------
function get_addon_status(wpn,addon)
	if addon == "sc" then
		return wpn:weapon_scope_status()
	elseif addon == "sl" then
		return wpn:weapon_silencer_status()
	elseif addon == "gl" then
		return wpn:weapon_grenadelauncher_status()
	end
	return 0
end

local rep_mem = {}

function get_addon_flag(wpn,with_int)
	local id,tg = wpn:id(),time_global()
	if tg == rep_mem.tg and rep_mem.id == id and rep_mem.wi == with_int then
		return rep_mem.fl
	else
		local flag = 0
		if wpn:weapon_is_scope() then
			if with_int or get_addon_status(wpn,"sc") == 2 then
				flag = 1
			end
		end
		if wpn:weapon_is_silencer() then
			if with_int or get_addon_status(wpn,"sl") == 2 then
				flag = flag+4
			end
		end
		if wpn:weapon_is_grenadelauncher() then
			if with_int or get_addon_status(wpn,"gl") == 2 then
				flag = flag+2
			end
		end
		rep_mem = {tg = tg,id = id,wi = with_int,fl = flag}
		return flag
	end
end

function addon_attached(wpn,addon,flag)
	local ft = {sc = {[1] = true,[3] = true,[5] = true,[7] = true},
				sl = {[4] = true,[5] = true,[6] = true,[7] = true},
				gl = {[2] = true,[3] = true,[6] = true,[7] = true}}
	if ft[addon] then
		return ft[addon][flag or get_addon_flag(wpn,true)] == true
	end
	return false
end

--******************
-- Storage from Rulix
--******************

function get_storage(id,name)
	if not id then
		return
	end
	local st = db.storage[id]
	if not st then
		local obj = level.object_by_id(id)
		local name = "uk"
		if obj then
			name = obj:character_name()
		end
		--printf("get_storage[%s:%s]:not npc storage! (%s)",id,name,tostring(name))
		return {}
	end
	if not st.ai_tweaks then
		st.ai_tweaks = {}
	end
	if not name then
		return st.ai_tweaks
	end
	if not st.ai_tweaks[name] then
		st.ai_tweaks[name] = {}
	end
	return st.ai_tweaks[name]
end

weapon_types_clslist = {
pistol = {[clsid.wpn_pm_s] = true,[clsid.wpn_walther_s] = true,[clsid.wpn_usp45_s] = true,[clsid.wpn_hpsa_s] = true,[clsid.wpn_lr300_s] = true},
sniper = {[clsid.wpn_svu_s] = true,[clsid.wpn_svd_s] = true,[clsid.wpn_vintorez_s] = true},
launcher = {[clsid.wpn_rg6_s] = true,[clsid.wpn_rpg7_s] = true},
shotgun = {[clsid.wpn_shotgun_s] = true,[clsid.wpn_auto_shotgun_s] = true},
rifle = {[clsid.wpn_ak74_s] = true,[clsid.wpn_groza_s] = true,[clsid.wpn_val_s] = true},
double_barreled = {[clsid.wpn_bm16_s] = true},
knife = {[clsid.wpn_knife_s] = true}}

function isPistol(wpn,clsid)
	if not (clsid) then
		clsid = wpn:clsid()
	end
	return weapon_types_clslist.pistol[clsid]
end

function isSniper(wpn,clsid)
	if not (clsid) then
		clsid = wpn:clsid()
	end
	return weapon_types_clslist.sniper[clsid]
end

function isLauncher(wpn,clsid)
	if not (clsid) then
		clsid = wpn:clsid()
	end
	return weapon_types_clslist.launcher[clsid]
end

function isShotgun(wpn,clsid)
	if not (clsid) then
		clsid = wpn:clsid()
	end
	return weapon_types_clslist.shotgun[clsid] or weapon_types_clslist.double_barreled[clsid]
end

function isRifle(wpn,clsid)
	if not (clsid) then
		clsid = wpn:clsid()
	end
	return weapon_types_clslist.rifle[clsid]
end

--***************************************
--* save_var(game_object,name,value)
--* load_var(game_object,name,def_value)
--*--------------------------------------
--* Stores/Loads variable with xr_logic's
--* pstor functions.
--***************************************
function save_var(npc,var,val)
	xr_logic.pstor_store(npc,var,val)
	return val
end

function load_var(npc,var,def)
	return xr_logic.pstor_retrieve(npc,var,def)
end

--**********************************************************************************************************************************
--* Staging! Makes stepping or staging within userobj (class) functions a breeze!
--*---------------------------------------------------------------------------------------------------------------------------------
--*	get_stage(userobj)			--> Returns current stage
--* set_stage(userobj,value)	--> sets current stage
--* next_stage(userobj)			--> goto next stage
--**********************************************************************************************************************************
function get_stage(userobj)
	if (userobj.stage == nil) then
		userobj.stage = 0
	end
	return userobj.stage
end
function set_stage(userobj,value)
	if ( userobj.stage ) then
		userobj.stage = value
		return true
	end
	return false
end
function next_stage(userobj)
	if ( userobj.stage ) then
		userobj.stage = userobj.stage + 1
		return true
	end
	return false
end

--**********************************************************************************************************************************
--* Timing! Makes running userobj functions take up less cpu time if only needed to be ran on a certain time
--*---------------------------------------------------------------------------------------------------------------------------------
--*	set_timer(userobj,value)	--> sets timer to time_global() + value
--* set_stage(userobj,value)	--> gets timer flag. Nil for empty, 1 for expired and -1 for on going
--**********************************************************************************************************************************
function set_timer(userobj, time)
	if not ( userobj ) then
		return
	end
	userobj.timer = time_global() + time
end

function get_timer(userobj)
	if ( userobj.timer ~= nil ) then
		if ( time_global() > userobj.timer ) then
			userobj.timer = nil
			return 1
		else
			return -1
		end
	end
	return nil
end

local exec_queue = {}
local exec_data = {}
local remove_me = {}
function execute_queue()
	local id
	local se_obj
	local sim = alife()

	for i=#exec_queue, 1, -1 do
		id = exec_queue[i]
		se_obj = id and sim:object(id)
		if not (se_obj) then
			-- object no longer exists
			exec_data[id] = nil
			table.insert(remove_me,i)
		end

		if not (se_obj.online) then
			-- execute function and switch online
			--alun_utils.printf("offline execute 1")
			exec_data[id].f(se_obj,exec_data[id].p)
			exec_data[id] = nil
			table.insert(remove_me,i)

			local parent = se_obj.parent_id ~= 65535 and alife():object(se_obj.parent_id)
			if (parent and not exec_data[se_obj.parent_id]) then
				parent:switch_online()
			else
				se_obj:switch_online()
			end
			--alun_utils.printf("offline execute 2")
		else
			local obj = level.object_by_id(id)
			if (IsStalker(se_obj)) then
				if (obj) then
					if (not db.actor:see(obj) or (alun_utils.angle_diff(db.actor:direction(), db.actor:position():sub(obj:position()))<90 and obj:position():distance_to(db.actor:position()) > 2.5) or obj:position():distance_to(db.actor:position())>100) then
						se_obj:switch_offline()
					end
				end
			else
				--[[
				local parent = se_obj.parent_id ~= 65535 and alife():object(se_obj.parent_id)
				if (parent and not exec_data[parent.id]) then
					if (IsStalker(parent)) then
						local obj = level.object_by_id(parent.id)
						if (not db.actor:see(obj) or (alun_utils.angle_diff(db.actor:direction(), db.actor:position():sub(obj:position()))<90 and obj:position():distance_to(db.actor:position()) > 2.5) or obj:position():distance_to(db.actor:position())>100) then
							parent:switch_offline()
						end
					else
						parent:switch_offline()
					end
				else
					se_obj:switch_offline()
				end
				--]]
				local parent = se_obj.parent_id ~= 65535 and alife():object(se_obj.parent_id)
				if (parent and not exec_data[se_obj.parent_id]) then
					parent:switch_offline()
				else
					se_obj:switch_offline()
				end
			end
		end
	end

	for i=#remove_me,1,-1 do
		table.remove(exec_queue,remove_me[i])
		table.remove(remove_me,i)
	end
end

function switch_offline_execute(id,func,...)
	if not (exec_data[id]) then
		exec_data[id] = {}
		exec_data[id].f = func
		exec_data[id].p = {...}
		table.insert(exec_queue,id)
	end
end

--**********************************************************************************************************************************
--* memoize(function)		--> Memoizies a function with a weak table
--**********************************************************************************************************************************
function memoize (f)
	local mem = {} -- memoizing table
	setmetatable(mem, {__mode = "kv"}) -- make it weak
	return function (x) -- new version of ’f’, with memoizing
	local r = mem[x]
		if r == nil then -- no previous result?
			r = f(x) -- calls original function
			mem[x] = r -- store result for reuse
			end
		return r
	end
end

--local loadstring = memoize(loadstring)


---------------------------------------- Path Nodes
class "position_node"
function position_node:__init(amt)
	self.node = {}
	for i=1,amt do
		self.node[i] = {}
	end
end

function position_node:select_best_vertex_id(object,dir,lvid,distance)
	local closest
	for i=1, #self.node do
		if	(bit_and(i,1)) then
			self.node[i].desired_direction = vector_rotate_y(dir, -math.random(50,60))
		else
			self.node[i].desired_direction = vector_rotate_y(dir, math.random(50,60))
		end

		self.node[i].vertex_id = level.vertex_in_direction(lvid, self.node[i].desired_direction, distance)

		if (self.node[i].vertex_id and object:accessible(self.node[i].vertex_id)) then
			self.node[i].distance = self.node[i].vertex_id == lvid and -1 or object:position():distance_to_sqr(level.vertex_position(self.node[i].vertex_id))

			if not (closest) then
				closest = self.node[i].vertex_id
			end

			if (self.node[i-1] and self.node[i-1].distance < self.node[i].distance) then
				closest = self.node[i-1].vertex_id
			end
		end
	end
	return closest and closest ~= -1 and closest
end

-------------------------------------------- INI utils

-- INI Reader
function file_to_table(fname)
	local root = {}
	local links
	local includes
	local sec, t,_root,_links
	for line in io.lines(fname) do
		if not (line == "" or line == "\n") then
			if (startsWith(line, "#include")) then
				t = str_explode(line,";")
				t = str_explode(t[1],[["]])

				if not (includes) then
					includes = {}
				end

				table.insert(includes,t[2])
				_root,_links = file_to_table(t[2])
				for k,v in pairs(_root) do root[k] = v end

				if (_links) then
					if not (links) then
						links = {}
					end
					for k,v in pairs(_links) do links[k] = v end
				end
			elseif (startsWith(line, "[")) then
				t = str_explode(line,";")
				t = str_explode(t[1],":")

				sec = string.sub(t[1],2,-2)
				root[sec] = {}

				t = t[2] and str_explode(t[2],",")
				if (t) then
					for k, v in ipairs(t) do
						if not (links) then
							links = {}
						end

						links[sec] = v
					end
				end
			elseif (not startsWith(line, ";")) then
				t = str_explode(line,";")
				t = str_explode(t[1],"=")
				if (sec) then
					root[sec] = root[sec] or {}
					root[sec][t[1]] = t[2] or ""
				else
					root[t[1]] = t[2] or ""
				end
			end
		end
	end
	return root,links,includes
end

class "cfg_file"
function cfg_file:__init(fname)
	local cfg = io.open(fname,"a+")
	cfg:close()
	self.fname = fname
	self.root,self.links,self.includes = file_to_table(fname)
end

function cfg_file:GetValue(sec,key,typ,def)
	local val = self.root and self.root[sec] and self.root[sec][key] or self.links and self.links[sec] and self.root[self.links[sec]] and self.root[self.links[sec]][key]
	if (val == nil) then
		return def
	end

	if (typ == 1 or typ == "bool") then
		return val == "true"
	elseif (typ == 2 or typ == "number") then
		return tonumber(val)
	end
	return val
end

function cfg_file:GetKeys(sec)
	return self.root and self.root[sec]
end

function cfg_file:SetValue(sec,key,val)
	if not (self.root) then
		self.root = {}
	end

	if not (self.root[sec]) then
		self.root[sec] = {}
	end

	self.root[sec][key] = val == nil and "" or tostring(val)
end

function cfg_file:SectionExist(sec)
	return self.root and self.root[sec] ~= nil
end

function cfg_file:KeyExist(sec,key)
	return self.root and self.root[sec] and self.root[sec][key] ~= nil
end

function cfg_file:SaveExt()
	local t,sec,comment
	local str = ""
	for ln in io.lines(self.fname) do
		ln = trim(ln)
		if (startsWith(ln,"[")) then
			t = str_explode(ln,";")
			t = str_explode(t[1],":")

			sec = string.sub(t[1],2,-2)
		elseif (not startsWith(ln,";") and self.root[sec]) then
			comment = string.find(ln,";")
			comment = comment and string.sub(ln,comment) or ""

			t = str_explode(ln,"=")
			if (self.root[sec][t[1]] ~= nil) then
				if (self.root[sec][t[1]] == "") then
					ln = t[1] .. "\t" .. comment
				else
					ln = t[1] .. " = " .. tostring(self.root[sec][t[1]]) .. "\t" .. comment
				end
			end
		end
		str = str .. ln .. "\n"
	end
	local cfg = io.open(self.fname,"w+")
	cfg:write(str)
	cfg:close()
end

function cfg_file:Save()
	local str = "",count

	if (self.includes) then
		for i=1,#self.includes do
			str = str .. self.includes[i] .. "\n"
		end
	end

	for section,tbl in pairs(self.root) do
		str = str .. "[" .. section .. "]\n"

		if (self.links and self.links[section]) then
			str = str .. ":"
			count = #self.links[section]
			for i=1,count do
				if (count > 1 and i ~= count) then
					str = str .. self.links[section][i] .. ","
				else
					str = str .. self.links[section][i]
				end
			end
		end

		for key,val in pairs(self.root[section]) do
			if (val == nil or val == "") then
				str = str .. key .. "\n"
			else
				str = str .. key .. " = " .. tostring(val) .. "\n"
			end
		end
	end

	local cfg = io.open(self.fname,"w+")
	cfg:write(str)
	cfg:close()
end

function startsWith(text,prefix)
	return string.sub(text, 1, string.len(prefix)) == prefix
end

function w_stpk(stpk,typ,n,info)
	local isError

	if (typ == "bool") then
		if (n and type(n) == "boolean") then
			stpk:w_bool(n)
		elseif (n and type(n) == "string") then
			isError = true
			if (n == "true") then
				stpk:w_bool(true)
			elseif (n == "false") then
				stpk:w_bool(false)
			end
			info = info .. " |-> auto-corrected bool value from string"
		else
			if (n) then
				isError = true
			end
			stpk:w_bool(false)
		end

	elseif (typ == "s8") then
		if (n and type(n) == "number" and n >= -128 and n <= 128) then
			stpk:w_s8(n)
		else
			isError = true
			stpk:w_s8(0)
		end

	elseif (typ == "s16") then
		if (n and type(n) == "number" and n >= -32768 and n <= 32767) then
			stpk:w_s16(n)
		else
			isError = true
			stpk:w_s16(0)
		end

	elseif (typ == "s32") then
		if (n and type(n) == "number" and n >= -2147483648 and n <= 2147483647) then
			stpk:w_s32(n)
		else
			isError = true
			stpk:w_s32(0)
		end

	elseif (typ == "s64") then
		if (n and type(n) == "number" and n >= -9223372036854775808 and n <= 9223372036854775808) then
			stpk:w_s64(n)
		else
			isError = true
			stpk:w_s64(0)
		end

	elseif (typ == "u8") then
		if (n and type(n) == "number" and n >= 0 and n <= 255) then
			stpk:w_u8(n)
		else
			isError = true
			stpk:w_u8(0)
		end

	elseif (typ == "u16") then
		if (n and type(n) == "number" and n >= 0 and n <= 65535) then
			stpk:w_u16(n)
		else
			isError = true
			stpk:w_u16(0)
		end

	elseif (typ == "u32") then
		if (n and type(n) == "number" and n >= 0 and n <= 4294967295) then
			stpk:w_u32(n)
		else
			isError = true
			stpk:w_u32(0)
		end

	elseif (typ == "u64") then
		if (n and type(n) == "number" and n >= 0 and n <= 18446744073709551615) then
			stpk:w_u64(n)
		else
			isError = true
			stpk:w_u64(0)
		end

	elseif (typ == "float") then
		if (n and type(n) == "number") then
			stpk:w_float(n)
		else
			isError = true
			stpk:w_float(0)
		end

	elseif (typ == "stringZ") then
		if (n and type(n) == "string") then
			if (string.len(n) > 255) then
				isError = true
				info = info .. " |-> length of string is too long for stringZ"
			end
			stpk:w_stringZ( string.sub(n,0,255) )
		elseif (n and type(n) ~= "userdata") then
			stpk:w_stringZ(tostring(n))
		else
			--isError = true
			stpk:w_stringZ("nil")
		end

	elseif (typ == "CTime") then
		if (n and type(n) == "userdata" and n.timeToString) then
			utils.w_CTime(stpk,n)
		else
			--printf("w_stpk:Debug: CTime is nil [%s]",info)
			utils.w_CTime(stpk,nil)
		end
	else
		isError = true
	end

	if (isError) then
		printf("w_stpk:CRITICAL ERROR: write %s (%s) TrueType=%s [%s]   | Packet:w_tell()=>%s",typ,type(n) ~= "userdata" and tostring(n) or "userdata",type(n),info,stpk:w_tell())
	else
		--printf("w_stpk:DEBUG: write %s (%s) TrueType=%s [%s]   | Packet:w_tell()=>%s",typ,type(n) ~= "userdata" and tostring(n) or "userdata",type(n),info,stpk:w_tell())
	end
end

function findfunction(x,tbl)
	assert(type(x) == "string")
	local f=tbl
	for v in x:gmatch("[^%.]+") do
		if type(f) ~= "table" then
			printf("looking for '%s' expected table, not %s",v,type(f))
			return
		end
		f=f[v]
	end
	if type(f) == "function" then
		return f
	else
		printf("expected function, not %s",type(f))
		return nil
	end
end

local fsgame
function get_fsgame()
	if (fsgame) then
		return fsgame
	end

	local root = file_to_table("fsgame.ltx")

	local fsgame = {}
	fsgame["$fs_root$"] = ""
	for k,v in pairs(root) do
		local t = str_explode(v,"|")
		local r = str_explode(root[t[3]],"|")
		fsgame[k] = (r and r[4] or "") .. (t and t[4] or "")
	end
	return fsgame
end

function fspath(str)
	local fsg = get_fsgame()
	return fsg[str] or ""
end

function fsgame_append(str,ap)
	if (fspath(str) ~= "" and fspath(str) ~= nil) then
		return
	end
	fsgame = nil

	local fsg = io.open("fsgame.ltx","a+")
	local data = fsg:read("*all")
	if not (string.find(data,str)) then
		fsg:write("\n"..ap)
	end
	fsg:close()
end
