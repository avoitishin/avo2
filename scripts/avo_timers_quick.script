--[[-- INFO -------------------------------------------------------------------
	File				: avo_timers_quick
	Description	: Quick timers
	Credits			: malandrinus, aVo
	Revision		: 0.1
	Change Date	: 08.04.2014
--]] --------------------------------------------------------------------------

--[[-- TODO -------------------------------------------------------------------
	1. Update HOWTO
--]]---------------------------------------------------------------------------

--/----------------------------------------------------------------------------
--/ Variables & Constants
--/----------------------------------------------------------------------------
local SELF_NAME = script_name()

--/----------------------------------------------------------------------------
--/ Initialization
--/----------------------------------------------------------------------------
function _init()
	local CFG_FILE = avo.MOD_FOLDER..SELF_NAME..".ltx"
	local ini = ini_file(CFG_FILE)
	
	-- avo.timer = this.quick_timer
	avo.ext_namespace("avo","timer",this.quick_timer,SELF_NAME,"Low footprint non persistent timer class")
	
	ini = nil
	wlog("%s is ready", SELF_NAME)
end

--/----------------------------------------------------------------------------
--/ CLASS: quick_timer - low weight non persistent timer
--/----------------------------------------------------------------------------
class "quick_timer"
-- конструктор таймера в базовом классе
function quick_timer:__init(timeout)
	self.timeout = timeout
end

-- Запуск таймера, аргумент задаёт частоту проверки в миллисекундах(пример: timer:start(10000) будет проверять время или условие каждые 10 секунд)
function quick_timer:start(check_interval)
	if self.timeout then -- если при создании задавали таймаут
		self.termination_time = time_global() + self.timeout -- то запоминаем время останова
	end
	self.slot = slot("actor_update", self.aux_cond, check_interval, true, self)
end

-- функция принудительного останова, никаких действий при этом не выполняется
function quick_timer:stop()
	sm:unsubscribe(self.slot)
end

-- проверка в базовом классе таймера обеспечивает сервис остановки по таймауту
-- и возможность принудительной остановки
function quick_timer:aux_cond()
	if self.termination_time and time_global() > self.termination_time then -- если сработал таймаут
		self:taction() -- выполняем действие по таймауту
		self:stop()    -- останавливаем проверки
	elseif self:condition() then -- если сработало условие
		self:action() -- выполняем действие по условия
		self:stop()
	end
end
-- условие-заглушка на случай использования только с таймаутом
function quick_timer:condition()
	return false
end
-- пустое действие в базовом классе. Нужно для того случая, 
-- когда по каким-то причинам не задаём действие в унаследованном классе
function quick_timer:action()
end
function quick_timer:taction() -- аналогичная заглушка для действия по таймауту
end



-------------------------------------------------------------------------------
--| ogse_qt.script                                                          |--
--| Quick Timers module                                                     |--
--| Malandrinus, OGS Evolution Team, 2011                                   |--
--| version 2.0                                                             |--
-------------------------------------------------------------------------------

---------------------------------------------------------------------------------
--< базовый класс легковесного таймера для отслеживания произвольного события >--
---------------------------------------------------------------------------------
-- зависит от модуля сигналов ogse_signals. Используется динамическая подписка и отписка
-- метода класса на событие периодической проверки
-- Комментарии:
-- 1. Наличие вашего конструктора обязательно. Вызов конструктора базового класса super(timeout) 
--    нужен только если используется возможность завершения по таймауту.
-- 2. При останове по таймауту действие, заданное методом action, выполнено не будет. Вместо 
--    него выполнится действие, заданное taction
-- 3. Пока таймер работает, можно остановить его работу принудительно так
-- timer_object:stop()
-- В этом случае действие также выполнено не будет.
-- 6. Таймеров одного класса можно запускать несколько. Сколько именно, определяется 
--    только памятью и резервами процессора
-- 7. Эти таймеры в сейве не сохраняются. Это означает, что с их помощью можно отслеживать только 
--    события, которые должны произойти "скоро", т.е. с гарантией до ближайшей загрузки 
--    или перехода на другой уровень.
-- 8. Частота срабатывания проверок регулируется параметром метода start. Если параметр не задан, 
--    то таймер будет проверяться с частотой апдейтов биндера актора. Если параметр задан 
--    и равен true, то проверки будут выполняться с низким приоритетом. Частота проверок при этом 
--    будет зависеть от количества низкоприоритетных вызовов, завязанных на событие "on_update".
--    Чем подписчиков больше, тем частота ниже. Это имеет смысл для проверок с низкой точностью
--    измерения момента времени и относительно длительным интервалом.

-- Пример 1 простейшего таймера, делающего что-то через заданное время после запуска:
--class "simple_timer" (ogse_qt.quick_timer)
--function simple_timer:__init(time) super(time)
--end
--function simple_timer:taction() -- наше действие по таймауту
--   здесь что-то делаем по факту срабатывания таймера
--end
-- Использование:
-- simple_timer(3000):start() -- сработает через три секунды
-- simple_timer(3000):start(true) -- сработает через три секунды, но проверяться будет реже


-- Пример 2 использования таймера для отслеживания удаления объекта из инвентаря:
--class "release_watch_timer" (ogse_qt.quick_timer)
--function release_watch_timer:__init(id) -- здесь решили не использовать таймаут
--   self.client_id = id -- запомнили объект, за которым следим
--end
--function release_watch_timer:condition()
--	  return not level.object_by_id(self.client_id) -- сработает по исчезновению клиентского объекта
--end
--function release_watch_timer:action() -- наше действие
--   здесь что-то делаем по факту ухода объекта в оффлайн
--end
-- Использование:
-- alife():release(sobj, true)
-- release_watch_timer(sobj.id):start()


