--[[-- INFO -------------------------------------------------------------------
	File				: avo_lua
	Description	: Various LUA extensions (string, table, math, etc)
	Credits			: aVo, Artos, xStream, malandrinus, RVP
	Revision		: 0.3
	Change Date	: 08.03.2014
--]] --------------------------------------------------------------------------

--[[-- TODO -------------------------------------------------------------------
	1. Resolve clashed with alun_util's string.split declaration
	2. Refactor table functions
	3. Add ability to use multilevel namespaces (avo.gu.test) in ext_namespace
--]]---------------------------------------------------------------------------

--/----------------------------------------------------------------------------
--/ Variables	& Constants	
--/----------------------------------------------------------------------------
local SELF_NAME = script_name()

--/----------------------------------------------------------------------------
--/ Initialization
--/----------------------------------------------------------------------------
function _init()
	local CFG_FILE = avo.MOD_FOLDER..SELF_NAME..".ltx"
	local ini = ini_file(CFG_FILE)
	
	local IS_LUA_EXT = avo.read_ini(ini,"lua_extensions","enabled","bool",true) -- is lua_enxtesions.dll being used. Change to true|false in config file
	
	-- avo.ext_namespace = this.ext_namespace
	ext_namespace("avo","ext_namespace", this.ext_namespace, SELF_NAME, "Protection against overrides when extending existing namespaces with new functions, tables, and classes (userdata)")
	-- avo.IS_LUA_EXT = IS_LUA_EXT
	
	
	if IS_LUA_EXT then
		require('lua_extensions') -- turn on RvP lua extensions (requires bin\lua_extensions.dll)
		if not lfs.dir then abort("[%s]: Failed to load lua_enxtesions", SELF_NAME) end
		--/ STRING:
		local tmp = string.trim
		string.trim = nil
		avo.ext_namespace("string","trim", tmp, SELF_NAME, "Trim whitespaces on both sides of the string (LUA Extensions)")
		tmp = string.trim_l
		string.trim_l = nil
		avo.ext_namespace("string","trim_l", tmp, SELF_NAME, "Trim whitespaces on left side of the string (LUA Extensions)")
		tmp = string.trim_r
		string.trim_r = nil
		avo.ext_namespace("string","trim_r", tmp, SELF_NAME, "Trim whitespaces on right side of the string (LUA Extensions)")
		tmp = string.trim_w
		string.trim_w = nil
		avo.ext_namespace("string","trim_w", tmp, SELF_NAME, "Get first word from a string (LUA Extensions)")
		tmp = string.pack
		string.pack = nil
		avo.ext_namespace("string","pack", tmp, SELF_NAME, "Pack binary data into a string (LUA Extensions)")
		tmp = string.unpack
		string.unpack = nil
		avo.ext_namespace("string","unpack", tmp, SELF_NAME, "Unpack binary data from a string (LUA Extensions)")
		--/ TABLE:
		tmp = table.size
		table.size = nil
		avo.ext_namespace("table","size", tmp, SELF_NAME, "Get array/dictionary size (LUA Extensions)")
		tmp = table.keys
		table.keys = nil
		avo.ext_namespace("table","keys", tmp, SELF_NAME, "Returns list of table keys (LUA Extensions)")
		tmp = table.values
		table.values = nil
		avo.ext_namespace("table","values", tmp, SELF_NAME, "Returns list of table values (LUA Extensions)")
		tmp = table.random
		table.random = nil
		avo.ext_namespace("table","random", tmp, SELF_NAME, "Returns random key from table (LUA Extensions)")
		--/ MATH:
		tmp = math.random
		math.random = nil
		avo.ext_namespace("math","random", tmp, SELF_NAME, "Improved implementation of LUA version (LUA Extensions)")
		tmp = math.randomseed
		math.randomseed = nil
		avo.ext_namespace("math","randomseed", tmp, SELF_NAME, "Improved implementation of LUA version (LUA Extensions)")
		--/ LUA FILE SYSTEM:
		tmp = lfs.dir
		lfs.dir = nil
		avo.ext_namespace("lfs","dir", tmp, SELF_NAME, "Lua File System library (LUA Extensions)")
		--/ LUA MARSHAL: Fast serialization for Lua by Richard Hundt (https://github.com/richardhundt/lua-marshal)
		tmp = marshal.encode
		marshal.encode = nil
		avo.ext_namespace("marshal","encode", tmp, SELF_NAME, "Serializes a value to a byte stream (LUA Extensions)")
		tmp = marshal.decode
		marshal.decode = nil
		avo.ext_namespace("marshal","decode", tmp, SELF_NAME, "Deserializes a byte stream to a value (LUA Extensions)")
		tmp = marshal.clone
		marshal.clone = nil
		avo.ext_namespace("marshal","clone", tmp, SELF_NAME, "Deep clone a value (deep for tables and functions) (LUA Extensions)")
		
		tmp = nil
	else
		avo.ext_namespace("string","trim", this.trim, SELF_NAME, "Trim whitespaces on both sides of the string") --  trim spaces
		avo.ext_namespace("table","size", this.size, SELF_NAME, "Get array/dictionary size") -- get size of hash table
	end
	
	-- STRING:
	avo.ext_namespace("string","split",this.split, SELF_NAME, "Split string into table by delimiter")	-- split into table by delim
	avo.ext_namespace("string","form",this.form, SELF_NAME, "Custom (safer) version of string.format. Will not choke on userdata; vector; nil; etc") -- custom version of string.format
	avo.ext_namespace("string","get_filename",this.get_filename, SELF_NAME, "Get filename from path") -- get filename from path
	
	-- TABLE:
	if avo.read_ini(ini,"table_inspect","enabled","bool",true) then
		local inspect = require('gamedata.scripts.inspect') -- awesome table formatter from https://github.com/kikito/inspect.lua 
		avo.ext_namespace("table","print",inspect.inspect,SELF_NAME,"Human-readable representations of tables by Enrique Garcia Cota") -- format table data for print
	else
		avo.ext_namespace("table","print",this.print,SELF_NAME,"Human-readable representations of tables by Artos and avo") -- format table data for print
	end
	avo.ext_namespace("table","find",this.find,SELF_NAME,"Returns true if passed value exists in table")	-- check if value exists in table
	avo.ext_namespace("table","clone",this.clone,SELF_NAME,"Clone table with optional include for metatable. Userdata cannot be cloned")	-- clone table
	avo.ext_namespace("table","compress",this.compress,SELF_NAME,"Compresses table into string by converting some values to hex. By Artos") -- compress table into string
	avo.ext_namespace("table","uncompress",this.uncompress,SELF_NAME,"UnCompresses table from string. By Artos") -- uncompress table from string
	avo.ext_namespace("table","serialize",this.serialize,SELF_NAME,"Serialize table to string") -- serialize table into string
	avo.ext_namespace("table","unserialize",this.unserialize,SELF_NAME,"UnSerialize table from string") -- unserialize table from string
	
	-- MATH:
	avo.ext_namespace("math","isnan",this.isnan,SELF_NAME,"Check if the number value is a NaN (not a number)")
	avo.ext_namespace("math","isinf",this.isinf,SELF_NAME,"Check if the number value is positive or negative infinity")
	avo.ext_namespace("math","isfinite",this.isfinite,SELF_NAME,"Check if the given number has finite value i.e. it is not infinite or NAN")
	avo.ext_namespace("math","round",this.round,SELF_NAME,"Rounds value to the nearest integer or specified number of decimal places") -- round to decimal or integer
	avo.ext_namespace("math","rand",this.rand,SELF_NAME,"Better random number generator. If no arguments given will generate between zero and one") -- better random number generator
	
	-- _G["serpent"] = require("serpent")
	
	ini = nil
	wlog("%s is ready", SELF_NAME)
	return true	
end

--/----------------------------------------------------------------------------
--/ Protection against overrides when extending existing namespaces with new functions, tables, and classes (userdata)
--/ Also adds optional information that can be used to generate help file (CSV format)
--/ Parameters:
--/ ns - namespace (table, string, avo, etc..). Do NOT pass _G
--/ name - name of the function
--/ fn - function or table
--/ script - file where function is defined (optional). Used for help file
--/ descr - function description (optional). Used for help file. IMPORTANT: do NOT use commas in description!!!
--/----------------------------------------------------------------------------
function ext_namespace(ns, name, fn, script, descr)
	if type(ns) ~= 'string' or type(name) ~= 'string' or (type(fn) ~= 'function' and type(fn) ~= 'table' and type(fn) ~= 'userdata') then 
		abort("Invalid parameter types passed to ext_namespace(string, string, function/table/userdata): %s, %s, %s", type(ns),type(name), type(fn)) 
	end
	if _G[ns][name] then 
		abort("Function [%s] is already registered in [%s]", name, ns)
	else
		_G[ns][name] = fn
		if not _G[ns]["help"] then _G[ns]["help"] = {} end
		_G[ns]["help"][name] = {}
		_G[ns]["help"][name][1] = script or 'not available'
		_G[ns]["help"][name][2] = ns
		_G[ns]["help"][name][3] = name
		_G[ns]["help"][name][4] = descr or 'not available'
	end
end

--/----------------------------------------------------------------------------
--/ Generates CSV help file
--/ ns - namespace to generate help for or 'all' for all namespaces in _G that have help table
--/----------------------------------------------------------------------------
function generate_help(ns)
	local print_header = true
	local function write_data(namespace, file)
		if print_header then file:write("File,Namespace,Function,Description\n") end
		local tt = {}
		for _, v in pairs(_G[namespace]["help"]) do
			local s = ""
			for _, t in pairs(v) do
					s = s .. "," .. t
			end
			table.insert(tt, string.sub(s, 2))
		end
		for _, v in ipairs(tt) do
			file:write(v.."\n")
		end
		print_header = false
	end

	if ns == 'all' then
		local file = io.open("avo_functions.csv", "w+")
		for _, v in ipairs(table.keys(_G)) do
			if type(_G[v]) == 'table' and type(_G[v]["help"]) == 'table' then
				write_data(v, file)
			end
		end
		file:close()
	else
		local file = io.open("avo_functions.csv", "w+")
		if not _G[ns] or not _G[ns]["help"] then return end
		write_data(ns, file)
		file:close()
	end
end

--/----------------------------------------------------------------------------
--/ STRING FUNCTIONS
--/----------------------------------------------------------------------------
--/----------------------------------------------------------------------------
--/ Split string by delimiter. do_trim = true by default
--/----------------------------------------------------------------------------
function split(str, delim, do_trim)
	if do_trim == nil then do_trim = true end
	local t = {}
	if not delim then delim = ',' end
	if type(str) ~= 'string' then
		return t
	end
	local cpt = string.find(str, delim, 1, true)
	if cpt then
		repeat
			if do_trim then
				table.insert(t, trim(string.sub(str, 1, cpt-1)))
			else
				table.insert(t, string.sub(str, 1, cpt-1))
			end
			str = string.sub(str, cpt + string.len(delim))
			cpt = string.find(str, delim, 1, true)
		until cpt == nil
	end
	if not do_trim then
		table.insert(t, str)
	else
		table.insert(t, trim(str))
	end
	return t
end

--/----------------------------------------------------------------------------
--/ Trim whitespaces from both sides (has RVP alternative)
--/----------------------------------------------------------------------------
function trim(str)
	return (string.gsub(str, "^%s*(.-)%s*$", "%1"))
end

--/----------------------------------------------------------------------------
--/ Safe string.format alternative. Replaces each place holder %s with tostring(p) of parameters ...
--/----------------------------------------------------------------------------
function form(msg, ...)
  local function tostr(val)
    if type(val) == 'number' or type(val) == 'nil' then return tostring(val) -- number, nil
		elseif type(val) == 'boolean'  then return val and 'true' or 'false' -- boolean
    elseif type(val) == 'table' then return table.serialize(val) -- table
    elseif type(val) == 'userdata' then
      if type(val.getP) == 'function' then return string.format("vec(%.3f,%.3f,%.3f)", val.x, val.y, val.z) -- vector
      else return '<userdata>' end -- userdata
    elseif type(val) == 'string' then return val -- string
    else return '<'..type(val)..'>'
    end
  end
  if type(msg) ~= 'string' then return tostr(msg) end
  if next({...}) then -- with arguments
    local args, i = {...}, 1
    for k,v in pairs(args) do -- replace empty strings
      if v == '' then args[k] = '<empty>' end
    end
    for pat in msg:gmatch('%%[%.|d|s|%d]%.?%d?f?') do 
      if args[i] == nil then msg = msg:gsub('%'..pat, 'nil', 1) -- replace nil agruments with 'nil'
      elseif string.find(pat, '%%[%.|%d].*f') then msg = msg:gsub('%'..pat, string.format(pat, args[i]),1) -- format floats (%3.2f, %.4f, etc)
      else msg = msg:gsub('%'..pat, tostr(args[i]), 1) -- format the rest (%d and %s)
      end
      i = i + 1
    end
    return msg
  else -- no arguments
    return msg == '' and '<empty>' or msg
  end
end

--/----------------------------------------------------------------------------
--/ Get file name without extension from path
--/----------------------------------------------------------------------------
function get_filename(path)
	return tostring(string.match(trim(path), "^.*\\(.-)%.%a-$"))
end

--/----------------------------------------------------------------------------
--/ TABLE FUNCTIONS
--/----------------------------------------------------------------------------
--/----------------------------------------------------------------------------
--/ Check if value exists in the table
--/----------------------------------------------------------------------------
function find(val, tbl)
  for _, v in ipairs(tbl) do
    if v == val then
      return true
    end
  end
  return false
end

--/----------------------------------------------------------------------------
--/ Clone table (userdata is not cloned). with_meta - clone metatables, false by default
--/----------------------------------------------------------------------------
function clone(tbl, with_meta)
  local lookup_table = {}
  local function _copy(tbl)
    if type(tbl) ~= "table" then
      return tbl
    elseif lookup_table[tbl] then
      return lookup_table[tbl]
    end
    local new_table = {}
    lookup_table[tbl] = new_table
    for index, value in pairs(tbl) do
      new_table[_copy(index)] = _copy(value)
    end
		if with_meta then
			return setmetatable(new_table, _copy(getmetatable(tbl)))
		else
			return new_table
		end
  end
  return _copy(tbl)
end

--/----------------------------------------------------------------------------
--/ Return number of key-value pairs in a table. (Has RVP alternative)
--/----------------------------------------------------------------------------
function size(tbl)
	num = 0
	for _,_ in pairs(tbl or {}) do
    num = num + 1
	end
	return num
end

--/----------------------------------------------------------------------------
--/ Упаковка таблицы в строку (стринг) и обратная распаковка (by Artos)
--/ Внимание! Строки в структуре таблицы не должны содержать символов с кодами 0-31
--/----------------------------------------------------------------------------
--[[--------------------------------------------------------
	Формат упаковки:
	  table     ::= ( listtable | hashtable )
	  subtable  ::= ( listtable | hashtable )
	  listtable ::= 0x6 valuetype ( value | subtable 0x5 )
	  hashtable ::= keytype key valuetype ( value | subtable 0x5 )
	  keytype   ::= ( 0x1 | 0x2 | 0x7 )
	  valuetype ::= ( 0x1 | 0x2 | 0x3 | 0x4 | 0x7 )
--]]--------------------------------------------------------
local markers = { -- служебная таблица маркеров упаковки
	dec = {string.char(1), 1}, -- 0x1 (SOH) - 'number' (dec)
	str = {string.char(2), 2}, -- 0x2 (STX) - 'string'
	bln = {string.char(3), 3}, -- 0x3 (ETX) - 'boolean'
	tbl = {string.char(4), 4}, -- 0x4 (EOT) - 'table'
	tbe = {string.char(5), 5}, -- 0x5 (ENQ) - table-end
	tbi = {string.char(6), 6}, -- 0x6 (ACK) - table-list
	hex = {string.char(7), 7}  -- 0x7 (BEL) - number-hex
}
local type_to_marker = { ['nil']=0,['boolean']=1,['number']=2,['string']=3,['table']=4 }

-- упаковка таблицы (списка) 'tbl' в строку 'str'
function compress(tbl, recur) -- table [,(nil|true|false)]
	if type(tbl) ~= 'table' or getmetatable(tbl) then -- can not serialize a table that has a metatable associated with it.
		abort("(%s:compress) cannot compress [%s] types or there is a metatable", SELF_NAME, type(tbl))
		return "",true -- zero-string & error (не таблица!)
	elseif not next(tbl) then -- (отсутствует 1-й элемент таблицы)
		return "",false -- zero-string (таблица пуста)
	end
	recur = recur or {}
	
	-- локальная функция: проверка типа таблицы - list or hash
	local is_list = function(tbl)
		local list = false
		local cnt_index = #tbl -- длина индексированной части таблицы
		if cnt_index > 0 then -- есть элементы списка?
			-- индексы начинаются с 1 и за 'списком' отсутствует хеш-элемент
			if next(tbl) == 1 and not next(tbl,cnt_index) then
				for i=2,cnt_index-1 do -- цикл перепроверки: 'отсутствуют пустые элементы?'
					if tbl[i] == nil then -- пустышка?
						return false -- hash
					end
				end
				list = true -- list
			end
		end
		return list
	end
	-- локальная функция: упаковка (+конвертер) числа (number) в 'dec' или 'hex' строку (string)
	local pack_num_to_string = function(num)
		if num == math.modf(num) then -- отсутствует дробная часть
			local num_abs = math.abs(num) -- модуль числа
			if num_abs > 9 then -- число 2-x и более разрядное?
				local num_level = math.floor(math.log10(num_abs+1)) -- степень ближайшего к модулю бОльшего числа кратного 10-ти
				if num_abs >= 10^num_level and num_abs < 2^(4*num_level) then -- разрядность 'dec' > 'hex'?
					if num >= 0 then -- не отрицательное?
						return markers.hex[1] .. string.format('%X', num_abs) -- 'hex' строка
					end
					-- отрицательное - упаковываем со знаком
					return markers.hex[1] .. "-" .. string.format('%X', num_abs) -- 'hex' строка со знаком
				end
			end 
		end 
		return markers.dec[1] .. num -- 'dec' строка
	end
	-- локальная функция: упаковка ключа (индекса) элемента таблицы
	local pack_key = function(key)
		local marker = type_to_marker[type(key)] or -1 --/ 0...4
		if marker == 2 then -- 'number'
			return pack_num_to_string(key) -- 'dec|hex' строка
		elseif marker == 3 then -- 'string'
			return markers.str[1] .. key -- строка
		end
		abort("(%s:compress:pack_key) key type [%s] of key [%s] is not supported", SELF_NAME, type(key), key)
		-- return nil,true -- nil & error
	end
	-- локальная функция: упаковка значения элемента таблицы
	local pack_value = function(value)
		local marker = type_to_marker[type(value)] or -1 --/ 0...4
		if     marker == 2 then -- 'number'
			return pack_num_to_string(value) -- 'dec|hex' строка
		elseif marker == 3 then -- 'string'
			return markers.str[1] .. value -- строка
		elseif marker == 1 then -- 'boolean'
			return markers.bln[1] .. ((value and "1") or "0") -- 'bool' строка ('0'|'1')
		elseif getmetatable(value) then
			-- can not serialize a table
		elseif marker == 4 then -- 'table'
			if recur[tbl] then -- can not serialize recursive tables
				--return nil, true -- nil & error #???#
			end
			recur[tbl] = true
			return markers.tbl[1] .. compress(value,recur) .. markers.tbe[1] -- рекурсивный вызов
		end
		abort("(%s:compress:pack_value) value type [%s] is not supported", SELF_NAME, type(value))
		-- return nil,true -- nil & error
	end
	-- тело основной функции: all pack
	local temp_pack_strs = {} -- временная таблица для частей общей строки
	local key, val, err
	if is_list(tbl) then -- упаковывается список?
		table.insert( temp_pack_strs, markers.tbi[1] ) -- маркер 'list' (список)
		for i=1,#tbl do
			val, err = pack_value(tbl[i], recur)
			table.insert(temp_pack_strs, val)
		end
	else -- полная упаковка (ключ и значение)
		for k,v in pairs(tbl) do
			key, err = pack_key(k, recur)
			table.insert(temp_pack_strs, key)
			val, err = pack_value(v,recur)
			table.insert(temp_pack_strs, val)
		end
	end
	return table.concat(temp_pack_strs), nil -- строка
end

--/----------------------------------------------------------------------------
--/ Pаспаковка строки 'str' в таблицу
--/----------------------------------------------------------------------------
function uncompress(str)
	local str_len = str:len() -- длина строки
	-- локальная функция: по-символьный парсер строки 'str' от symb-го до 1-го 'управляющего' символа
	local get_str = function(symb) -- текущий индекс символа в строке
		for i=symb,str_len do
			local byte_code = string.byte(str:sub(i,i)) -- код i-го символа строки
			if byte_code < 32 then -- 'управляющий' символ?
				if byte_code > 7 or i == symb then -- запрещенный 'управляющий' символ или 1-й?
					abort("(%s:uncompress:get_str) encountered bad control symbol [%s] at position [%s]", SELF_NAME, byte_code, i)
				end
				return str:sub(symb,i-1),i -- str, i (субстрока и индекс 1-го упр.символа)
			end
		end
		return str:sub(symb,str_len) -- str (субстрока до конца строки)
	end
	-- локальная функция: конвертер субстроки (str) в десятичное число
	local get_num = function(str,hex_flag) -- hex_flag: флаг 'hex' строки
		local num = nil
		if not hex_flag then -- распаковки 'dec' строки?
			num = tonumber(str) -- перевод 'dec' строки в десятичное число
		else -- распаковка 'hex' строки
			if str:sub(1,1) ~= "-" then -- отсутствует символ '-' (минус)?
				num = tonumber(str,16) -- перевод 'hex'-строки в десятичное число ('0x'..str)
			else -- для отрицательного - отрезаем 1-й символ
				num = tonumber(str:sub(2,-1),16) *(-1) -- перевод 'hex'-строки в отрицательное десятичное число
			end
		end
		if not num then -- ошибка распаковки числа?
			abort("(%s:uncompress:get_num) error unpacking number from string [%s]", SELF_NAME, str)
		end
		return num -- number
	end
	-- тело основной функции: parse all
	parse = function(symb) -- парсинг строки 'str' с symb-го символа
		-- проверка: упакована таблица типа 'список' (table-list)?
		local byte_code = string.byte(str:sub(symb,symb)) -- код symb-го символа в строке
		symb = symb+1 -- переходим к следующему символу
		local list = byte_code == markers.tbi[2] -- флаг: 'начало списка' (table-list)
		if list then -- проверка: 'список'?
			byte_code,symb = string.byte(str:sub(symb,symb)), symb+1-- пропускаем маркер списка и переходим к следующему символу
		end
		local tbl,key,value = {},nil,nil
		-- цикл парсинга строки с symb-го символа
		while symb <= str_len do -- (суб)строка не закончилась?
			if byte_code == markers.tbe[2] then -- проверка: маркер конца субтаблицы (table-end)?
				return tbl,symb -- субстрока субтаблицы закончилась - выход из функции
			end
			if not list then -- проверка: не 'список'? -> режим 'общей' таблицы
				key,symb = get_str(symb) -- парсинг 'key'
				if byte_code == markers.dec[2] then -- 'number' (dec)?
					key = get_num(key, false) -- распаковка 'dec'-строки
				elseif byte_code == markers.hex[2] then -- 'number-hex'?
					key = get_num(key, true) -- 'true' - флаг распаковка 'hex'-строки
				elseif byte_code ~= markers.str[2] then -- не 'string'? -> ошибка формата упаковки
					abort("(%s:uncompress:parse) unsupported key type [%s] | key [%s] | byte code [%s] | str [%s]", SELF_NAME, symb, key, byte_code, str)
				end
				byte_code,symb = string.byte(str:sub(symb,symb)), symb+1 -- код следующего символа строки
			end
			-- проверка 'value'
			if byte_code == markers.tbl[2] then -- 'table'?
				value,symb = parse(symb) -- рекурсивный вызов для 'табличных субстрок'
			else -- парсинг 'value'
				value,symb = get_str(symb) -- парсинг 'value'
				if     byte_code == markers.dec[2] then -- 'number' (dec)?
					value = get_num(value, false) -- распаковка 'dec' строки
				elseif byte_code == markers.hex[2] then -- 'number-hex'?
					value = get_num(value, true) -- 'true' - флаг распаковка 'hex' строки
				elseif byte_code == markers.bln[2] then -- 'boolean'?
					value = value == "1"
				elseif byte_code ~= markers.str[2] then -- не 'string'? - ошибка формата упаковки
					abort("(%s:uncompress:parse) unsupported value type [%s] | key [%s] | value [%s] | byte code [%s] | str [%s]", SELF_NAME, symb, key, value, byte_code, str)
				end
			end
			-- запоминаем элемент в таблицу
			if list then -- элемент списка?
				table.insert(tbl, value) -- добавляем в таблицу типа 'список' (table-list)
			else -- элементы 'общей' таблицы
				tbl[key] = value
			end
			if symb then
				byte_code,symb = string.byte(str:sub(symb,symb)), symb+1 -- код следующего символа строки
			else
				return tbl -- строка закончилась - выход из функции
			end
		end
		return tbl,symb -- (sub)table
	end
	-- парсинг строки 'str' (с 1-го символа)
	return parse(1) or {} -- table
end

--/----------------------------------------------------------------------------
--/ Serialize table to string reprezentation
--/ in: table|nil|string|number|boolean, nil
--/ string|nil, boolean(error)
--/----------------------------------------------------------------------------
function serialize(x, recur)
	--local lua_type = type(x)
	local marker = type_to_marker[type(x)] -- 0...4
	if marker then
		recur = recur or {}
		
		if     marker == 3 then -- lua_type == 'string'
			return string.format('%q',x)
		elseif marker == 2 then -- lua_type == 'number'
			return tostring(x)
		elseif marker == 1 then -- lua_type == 'boolean'
			return x and "true" or "false"
		elseif marker == 0 then -- lua_type == 'nil'
			return "nil"
		elseif getmetatable(x) then -- can not serialize a table that has a metatable associated with it.
			return nil, true
		elseif marker == 4 then -- lua_type == 'table'
			if table.size(x) == 0 then return '{}' end
			if recur[x] then -- can not serialize recursive tables.
				return nil, true
			end
			recur[x] = true
			
			local str,key,val,err = "{",nil,nil,nil
			for k,v in pairs(x) do
				key,err = serialize(k, recur) -- recursive call
				if err then -- if something srong with table's keys
					return nil, true
				end
				val,err = serialize(v, recur) -- recursive call
				if err then -- if something srong with table's values
					return nil, true
				end
				str = str.."["..key.."]".."="..val..","
			end
			
			return str:sub(0, str:len() -1).."}"
		end
	end
	-- can not serialize value of passed type
	return nil, true
end

--/----------------------------------------------------------------------------
--/ Unserialize table from string
--/----------------------------------------------------------------------------
function unserialize(str)
	if not str then return {} end
	return loadstring("return " .. str)() or {}
end

--/----------------------------------------------------------------------------
--/ Format table as string suitable for printing
--/----------------------------------------------------------------------------
function print(tbl, title, mode) -- mode: key=true, value=false
	if type(tbl) == 'table' then
		local msg = "print table: "
		if type(title) == 'string' then
			msg = msg..title
		else
			title = ''
		end
		if mode then
			msg = msg.." (keys only)"
		elseif mode == false then
			msg = msg.." (values only)"
		end
		local out = string.format(">>>\n----| %s |----\n", msg)
		local level = '' -- sub-table level indicator
		--/------------------------------------------
		local function prnt(tbl_in)
			if next(tbl_in) then
				for k,v in pairs(tbl_in) do
					local key = type(k)
					if key == 'string' then
						key = k --string.format("%q", k)
					elseif key == 'number' then
						key = tostring(k)
					else
						key = "[<"..key..">]"
					end
					local val_type = type(v)
					if val_type == 'table' then
						if key == "_G" or (key == "loaded" and v["package"]) then
							level = level..'.'
							prnt({}) -- рекурсивный вызов
						else
							level = level..'.'
							prnt(v) -- рекурсивный вызов
						end
					else
						if val_type == 'string' then
							if v ~= '' then
								--v = string.format("%q", v)
								if v:len() > 255 then
									v = v:sub(1,255) --/ ограничиваем длину строки
								end
							else
								v = '<<zero_string>>'
							end
						elseif val_type == 'number' or val_type == 'boolean' then
							v = tostring(v)
						elseif val_type == 'userdata' then 
							if type(v.x) == 'number' and type(v.y) == 'number' and type(v.z) == 'number' then -- vector?
								v = '<vector>:'..string.format("x=%.3f:y=%.3f:z=%.3f", v.x, v.y, v.z)
							end
							v = '<<usedata>>'
						else
							v = '<<'..val_type..'>>'
						end
						if mode == nil then
							out = out..string.format("%s [%s] = %s\n", level, key, v)
						elseif mode then
							out = out..string.format("%s key = %s\n", level, key)
						else
							out = out..string.format("%s value = %s\n", level, v)
						end
					end
				end
			else -- пустая таблица
				return string.format("(%s) %s is empty table", SELF_NAME, title)
			end
		end
		level = '' -- reset sub-table level indicator

		prnt(tbl,title)
		out = out.."----| end of table print |----"
		return out
	else
		return string.format("(%s) [%s] is not a table", SELF_NAME, type(tbl))
	end
end

--/----------------------------------------------------------------------------
--/ MATH FUNCTIONS
--/----------------------------------------------------------------------------
local inf = 1/0
local nan = -(0/0)

--/----------------------------------------------------------------------------
--/ Check if the number value is a NaN (not a number)
--/----------------------------------------------------------------------------
function isnan(value)
	return value ~= value
end

--/----------------------------------------------------------------------------
--/ Check if the number value is positive or negative infinity
--/----------------------------------------------------------------------------
function isinf(value)
	if value == -inf then
		return -1
	elseif value == inf then
		return 1
	else
		return 0
	end
end

--/----------------------------------------------------------------------------
--/ Check if the given number has finite value i.e. it is not infinite or NAN
--/----------------------------------------------------------------------------
function isfinite(value)
	return value > -inf and value < inf
end

--/----------------------------------------------------------------------------
--/ Rounds value to the nearest integer or specified number of decimal places
--/----------------------------------------------------------------------------
function round(value, decimals)
	local mul = math.pow(10, decimals) -- 10^count
	return math.floor(value*mul + 0.5)/mul
end

--/----------------------------------------------------------------------------
--/ Better random number generator. If no arguments given will generate between zero and one
--/----------------------------------------------------------------------------
function rand(min_value, max_value)
	math.randomseed(device():time_global())
	if not min_value == nil and max_value == nil then
		return math.random()
	else
		return math.random(min_value, max_value)
	end
end

--[[-- HOWTO ------------------------------------------------------------------
	*** Defined as C functions in lua_extensions.dll ***
		string.trim		-- trim on both sides
		string.trim_l	-- trim left
		string.trim_r	-- trim right
		string.trim_w	-- get first word
		string.pack 	-- pack binary into string (similar to perl)
		string.unpack -- unpack binary from string (similar to perl)
		
		table.size		--  returns dictionary size
		table.keys		-- returns list of table keys
		table.values	-- returns list of table values
		table.random 	-- returns random key from table
		
		math.random
		math.randomseed
		
		lfs -- lua file system library
		
		marshal -- fast table serialization
		
		Marshal README:
		Fast serialization for Lua
		local marshal = require "marshal"
		
		Provides:
		
		s = marshal.encode(v[, constants]) - serializes a value to a byte stream
		t = marshal.decode(s[, constants]) - deserializes a byte stream to a value
		t = marshal.clone(orig[, constants]) - deep clone a value (deep for tables and functions)
		Features:
		
		Serializes tables, which may contain cycles, Lua functions with upvalues and basic data types.
		
		All functions take an optional constants table which, if encountered during serialization, are simply referenced from the constants table passed during deserialization. For example:
		
		local orig = { answer = 42, print = print }
		local pack = marshal.encode(orig, { print })
		local copy = marshal.decode(pack, { print })
		assert(copy.print == print)
		Hooks
		
		A hook is provided for influencing serializing behaviour via the __persist metamethod. The __persist metamethod is expected to return a closure which is called during deserialization. The return value of the closure is taken as the final decoded result.
		
		This is useful for serializing both userdata and for use with object-oriented Lua, since metatables are not serialized.
		
		For example:
		
		local Point = { }
		function Point:new(x, y)
			self.__index = self
			return setmetatable({ x = x, y = y }, self)
		end
		function Point:move(x, y)
			self.x = x
			self.y = y
		end
		function Point:__persist()
			local x = self.x
			local y = self.y
			return function()
					-- do NOT refer to self in this scope
					return setmetatable({ x = x, y = y }, Point)
			end
		end
		The above shows a way to persist an "instance" of Point (if you're thinking in OO terms). In this case Point itself will be included in the encoded chunk because it's referenced as an upvalue of the returned closure.
		
		The __persist hook may NOT refer to the receiver (i.e. self in the example) because this will cause deep recursion when upvalues are serialized.
		
		Limitations:
		
		Coroutines are not serialized. Userdata doesn't serialize either however support for userdata the __persist metatable hook can be used.
		
		Metatables and function environments are not serialized.
		
		Attempt to serialize C functions, threads and userdata without a __persist hook raises an exception.
		
		Serialized code is not portable.
--]]---------------------------------------------------------------------------