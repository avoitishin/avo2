--[[
	Copyright (C) 2012 Alundaio
	This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
--]]
function add_stalker(npc)
	if not (db.OnlineStalkers) then
		db.OnlineStalkers = {}
	end
	for i=#db.OnlineStalkers,1,-1 do
		if (npc:id() == db.OnlineStalkers[i]) then
			return
		end
	end
	table.insert(db.OnlineStalkers,npc:id())
end

function del_stalker(npc)
	if not (db.OnlineStalkers) then
		return
	end
	local index
	for i=#db.OnlineStalkers,1,-1 do
		if (npc:id() == db.OnlineStalkers[i]) then
			index = i
			break
		end
	end

	table.remove(db.OnlineStalkers,index)
end

function release_object(p)
	local sim = alife()
	local se_obj = p[1] and sim:object(p[1])
	if not (se_obj) then
		return true
	end

	if (se_obj.online) then
		se_obj:switch_offline()
		return false
	end

    if not (se_obj.marked_for_release) then
		if (dev_debug) then
			alun_utils.printf("safe released %s",se_obj:name())
		end
	   sim:release(se_obj,true)
       se_obj.marked_for_release = true
	end

	return true
end

-- Prints a formated lua table to print_table.txt for debugging purposes
function print_table(tbl,header)
	local txt = tostring(header) .. "\n{\n\n"
	local depth = 1

	local function tab(amt)
		local str = ""
		for i=1,amt, 1 do
			str = str .. "\t"
		end
		return str
	end

	local function table_to_string(tbl)
		local size = 0
		for k,v in pairs(tbl) do
			size = size + 1
		end

		local key
		local i = 1

		for k,v in pairs(tbl) do
			if (type(k) == "number") then
				key = "[" .. k .. "]"
			else
				key = "[\""..tostring(k) .. "\"]"
			end

			if (type(v) == "table") then
				txt = txt .. tab(depth) .. key .. " =\n"..tab(depth).."{\n"
				depth = depth + 1
				table_to_string(v,tab(depth))
				depth = depth - 1
				txt = txt .. tab(depth) .. "}"
			elseif (type(v) == "number" or type(v) == "boolean") then
				txt = txt .. tab(depth) .. key .. " = " .. tostring(v)
			elseif (type(v) == "userdata") then
				txt = txt .. tab(depth) .. key .. " = \"userdata\""
			else
				txt = txt .. tab(depth) .. key .. " = \"" .. tostring(v) .. "\""
			end

			if (i == size) then
				txt = txt .. "\n"
			else
				txt = txt .. ",\n"
			end

			i = i + 1
		end
	end

	table_to_string(tbl)

	txt = txt .. "\n}"

	local file = io.open("print_table.txt","a+")
	file:write(txt.."\n\n")
	file:close()
	printf("Table written to print_table.txt")
end

function accessible(npc,point)
	if (type(point) == "number") then
		return npc:accessible(point) and point < 4294967295
	end
	return npc:accessible(point) and level.vertex_id(point) < 4294967295
end

function is_in_same_squad(obj,npc)
	local squad1 = get_object_squad(obj)
	local squad2 = get_object_squad(npc)
	if ( squad1 and squad2 ) then
		if ( squad1.id == squad2.id ) then
			return true
		end
	end
	return false
end

function read_from_ini(ini,section,line,var_type,default,caller)
	if not (ini) then
		ini = system_ini()
	end

	if (section and line and ini:section_exist(section) and ini:line_exist(section,line)) then
		if (var_type == "bool") then
			return ini:r_bool(section,line)
		elseif (var_type == "string") then
			return ini:r_string(section,line)
		elseif (var_type == "float") then
			return ini:r_float(section,line)
		else
			return ini:r_string_wq(section,line)
		end
	else
		return default
	end
end

function trim(s)
	return string.gsub(s, "^%s*(.-)%s*$", "%1")
end

function string:split(pat)
	pat = pat or '%s+'
  local st, g = 1, self:gmatch("()("..pat..")")
  local function getter(self, segs, seps, sep, cap1, ...)
    st = sep and seps + #sep
    return self:sub(segs, (seps or 0) - 1), cap1 or sep, ...
  end
  local function splitter(self)
    if st then return getter(self, st, g()) end
  end
  return splitter, self
end

function str_explode(str,pattern)
	local t = {}
	if (type(str) ~= "string") then return end
	for word, pat, start in str:split(pattern) do
		t[#t+1] = trim(word)
		if (start and pat == pattern) then
		    t[#t+1] = trim(str:sub(start))
			break
		end
	end
	return t
end

function hex2string(str)
    return (str:gsub('..', function (cc)
        return string.char(tonumber(cc, 16))
    end))
end

function string2hex(str)
    return (str:gsub('.', function (c)
        return string.format('%02X', string.byte(c))
    end))
end

function float2hex (n)
    if n == 0.0 then return 0.0 end

    local sign = 0
    if n < 0.0 then
        sign = 0x80
        n = -n
    end

    local mant, expo = math.frexp(n)
    local hext = {}

    if mant ~= mant then
        hext[#hext+1] = string.char(0xFF, 0x88, 0x00, 0x00)

    elseif mant == math.huge or expo > 0x80 then
        if sign == 0 then
            hext[#hext+1] = string.char(0x7F, 0x80, 0x00, 0x00)
        else
            hext[#hext+1] = string.char(0xFF, 0x80, 0x00, 0x00)
        end

    elseif (mant == 0.0 and expo == 0) or expo < -0x7E then
        hext[#hext+1] = string.char(sign, 0x00, 0x00, 0x00)

    else
        expo = expo + 0x7E
        mant = (mant * 2.0 - 1.0) * math.ldexp(0.5, 24)
        hext[#hext+1] = string.char(sign + math.floor(expo / 0x2),
                                    (expo % 0x2) * 0x80 + math.floor(mant / 0x10000),
                                    math.floor(mant / 0x100) % 0x100,
                                    mant % 0x100)
    end

    return tonumber(string.gsub(table.concat(hext),"(.)",
                                function (c) return string.format("%02X%s",string.byte(c),"") end), 16)
end


function hex2float (c)
    if c == 0 then return 0.0 end
    local c = string.gsub(string.format("%X", c),"(..)",function (x) return string.char(tonumber(x, 16)) end)
    local b1,b2,b3,b4 = string.byte(c, 1, 4)
    local sign = b1 > 0x7F
    local expo = (b1 % 0x80) * 0x2 + math.floor(b2 / 0x80)
    local mant = ((b2 % 0x80) * 0x100 + b3) * 0x100 + b4

    if sign then
        sign = -1
    else
        sign = 1
    end

    local n

    if mant == 0 and expo == 0 then
        n = sign * 0.0
    elseif expo == 0xFF then
        if mant == 0 then
            n = sign * math.huge
        else
            n = 0.0/0.0
        end
    else
        n = sign * math.ldexp(1.0 + mant / 0x800000, expo - 0x7F)
    end

    return n
end

function parse_list(ini,key,val,convert)
	local str = read_from_ini(ini,key,val,"string","")
	local t = str and str ~= "" and str_explode(str,",")
	if not (t) then
		return
	end
	if (convert and #t > 0) then
		local l = {}
		for i,v in ipairs(t) do
			l[v] = true
		end
		return l
	end
	return t
end

function eval_condlist(npc, condlist, p)
	return xr_logic.pick_section_from_condlist(db.actor,npc, condlist, p)
end

function parse_condlist(str)
	if not (str) then
		printf("alun_utils.parse_condlist: Error no source string")
		return
	end

	local src = str_explode(str,",")
	local t = {}
	local a,b,infop_check_lst,infop_set_lst,remainings,new_sect
	for i=1,#src do
		a, b, infop_check_lst = string.find(src[i], "{%s*(.*)%s*}")
		if (infop_check_lst) then
			remainings = string.sub(src[i], 1, a - 1) .. string.sub(src[i], b + 1)
		else
			remainings = src[i]
		end

		a, b, infop_set_lst = string.find(remainings, "%%%s*(.*)%s*%%")
		if (infop_set_lst) then
			new_sect = string.sub(remainings, 1, a - 1) .. string.sub(remainings, b + 1)
		else
			new_sect = remainings
		end

		new_sect = trim(new_sect)

		t[i] = {}
		t[i].infop_check = {}
		t[i].infop_set = {}

		t[i].section = new_sect
		xr_logic.parse_infop(t[i].infop_check, infop_check_lst)
		xr_logic.parse_infop(t[i].infop_set, infop_set_lst)
	end
	return t
end

function collect_sections(ini,sections)
	local r,p = {},{}
	for k,v in ipairs(sections) do
		if ini:section_exist(v) then
			local n = ini:line_count(v)
			if n > 0 then
				for i = 0,n-1 do
					local res,id,val = ini:r_line(v,i,"","")
					if r[id] == nil then
						r[id] = val
					end
				end
			end
			p[k] = n
		else
			p[k] = 0
		end
	end
	return r,p
end

local ranks
function get_rank_list()
	if ranks then
		return ranks
	end
	local tmp = parse_list(nil,"game_relations","rating")
	ranks = {}
	for i,rn in ipairs(tmp) do
		if not tonumber(rn) then
			table.insert(ranks,rn)
		end
	end
	return ranks
end


local communities
function get_communities_list()
	if communities then
		return communities
	end
	local tmp = parse_list(nil,"game_relations","communities")
	communities = {}
	for i,cn in ipairs(tmp) do
		if not tonumber(cn) then
			table.insert(communities,cn)
		end
	end
	return communities
end

function execute_script_on_squad(obj,script_to_execute,...)
	local squad = get_object_squad(obj)

	if not ( squad ) then
		script_to_execute(obj,...)
		return
	end

	for k in squad:squad_members() do
		local member = db.storage[k.id] and db.storage[k.id].object

		if ( member and member:alive() ) then
			script_to_execute(member,...)
		end
	end
end


function execute_script_on_squad_not_commander(obj,script_to_execute,...)
	local squad = get_object_squad(obj)

	if not ( squad ) then
		script_to_execute(obj,...)
		return
	end

	for k in squad:squad_members() do
		local member = db.storage[k.id] and db.storage[k.id].object

		if ( member and member:alive() and member:id() ~= squad:commander_id() ) then
			script_to_execute(member,...)
		end
	end
end

function nearest_object(match)
	local dist
	local nearest
	local min_dist
	local is_match
	for i=1, 65535 do
		local obj = alife():object(i)
		if (obj) then
			is_match = false
			if (type(match) == "string" and string.find(obj:section_name(),match)) then
				is_match = true
			elseif (type(match) == "number" and match == obj:clsid()) then
				is_match = true
			end

			if (is_match) then
				dist = obj.position:distance_to_sqr(db.actor:position())

				if not(min_dist) then
					min_dist = dist
					nearest = obj
				elseif (dist < min_dist) then
					min_dist = dist
					nearest = obj
				end
			end
		end
	end

	if (nearest) then
		if (simulation_objects.is_on_the_same_level(nearest, alife():actor()) and min_dist <= alife():switch_distance()^2) then
			return nearest,min_dist
		end
	end
end

-- level object only

function get_nearest_stalker(npc)
	if not (db.OnlineStalkers) then
		return
	end
	local stalker
	local dist
	local nearest_stalker,nearest_dist
	local pos
	local st
	for i=1, #db.OnlineStalkers do
		st = db.storage[db.OnlineStalkers[i]]
		stalker = st and st.object or level.object_by_id(db.OnlineStalkers[i])
		if (stalker and stalker:alive()) then
			pos = npc == "cam" and device().cam_pos or npc:position()
			dist = pos:distance_to_sqr(stalker:position())
			if not (nearest_dist) then
				nearest_dist = dist
				nearest_stalker = stalker
			end

			if (dist < nearest_dist) then
				nearest_dist = dist
				nearest_stalker = stalker
			end
		end
	end
	return nearest_stalker,nearest_dist
end

function get_nearest_object(npc,...)
	local p = {...}
	local match
	local lowest_dist = p[2]
	for key, value in pairs(p[1]) do
		local obj
		if ( value.object ) then
			obj = value.object
		else
			obj = value
		end
		if ( obj and obj.position ) then
			dist = npc:position():distance_to_sqr(obj:position())

			if ( dist < lowest_dist ) then
				lowest_dist = dist
				match = obj
			end
		end
	end

	if ( match ) then
		return match,lowest_dist
	end
end

function get_squad_count(npc)
	local squad = get_object_squad(npc)

	if not ( squad ) then
		return 1
	end
	local c = 0
	for k in squad:squad_members() do
		c = c + 1
	end
	return c
end

function safe_release(p)
	local sim = alife()
	local se_obj = p[1] and sim:object(p[1])
	if not (se_obj) then
		return true
	end

	-- wait for it to switch offline
	if (se_obj.online) then
		--se_obj:switch_offline()
		sim:set_switch_online(p[1],false)
		sim:set_switch_offline(p[1],true)
		return false
	end

	-- release stalker
	sim:release(se_obj,true)

	return true
end

function release(se_obj)
	if (se_obj) then
		local sim = alife()
		sim:release(se_obj,true)
	end
end

function create(p)
	--printf("section=%s position=%s lvid=%s gvid=%s",p[1],vector_to_string(p[2]),p[3],p[4])
	alife():create(p[1],p[2],p[3],p[4])
end

function get_current_action_id(npc)
	local mgr = npc:motivation_action_manager()

	if not mgr:initialized() then
		return false
	end

	return mgr:current_action_id()
end

function item_is_fa(o,c)
	if not c then
		c = o and o:clsid()
	end
	local t = {
	[clsid.wpn_pm_s] = true,
	[clsid.wpn_walther_s] = true,
	[clsid.wpn_usp45_s] = true,
	[clsid.wpn_hpsa_s] = true,
	[clsid.wpn_bm16_s] = true,
	[clsid.wpn_shotgun_s] = true,
	[clsid.wpn_auto_shotgun_s] = true,
	[clsid.wpn_ak74_s] = true,
	[clsid.wpn_lr300_s] = true,
	[clsid.wpn_groza_s] = true,
	[clsid.wpn_val_s] = true,
	[clsid.wpn_vintorez_s] = true,
	[clsid.wpn_svu_s] = true,
	[clsid.wpn_svd_s] = true,
	[clsid.wpn_rg6_s] = true,
	[clsid.wpn_rpg7_s] = true,
	[clsid.wpn_knife_s] = true}
	if c and t[c] then
		return true
	end
	return false
end

function item_is_outfit(o,c)
	if not c then
		c = o and o:clsid()
	end
	local t = {
	[clsid.equ_stalker_s] = true}
	if c and t[c] then
		return true
	end
	return false
end

function item_is_explosive(o,c)
	if not c then
		c = o and o:clsid()
	end
	local t = {
	[clsid.obj_explosive_s] = true}
	if c and t[c] then
		return true
	end
	return false
end

function is_actor(object,c)
	if not (c) then
		c = object and object:clsid()
	end
	return c == clsid.script_actor or c == clsid.actor or c == clsid.spectator or object and object:id() == db.actor:id()
end

function add_anim(npc,anim)
	if anim then
		npc:add_animation(anim,true,false)
	end
end

function get_sound(snd)
	if snd then
		return sound_object(snd)
	end
end

function safe_bone_pos(npc,bone)
    if not (npc) then
		printf("safe_bone_pos: npc is nil!")
		return
    end

	local pos

	--[[
	local cls = npc:clsid()
	if (cls == clsid.burer_s) then
		pos = utils.vector_copy_by_val(npc:position())
		pos.y = pos.y + 1
	elseif cls == clsid.gigant_s then
		pos = npc:bone_position("bip01_spine")
	else
	--]]

	if (IsStalker(npc)) then
		pos = npc:bone_position(bone or "bip01_spine")
	end

	if not (pos) then
		pos = utils.vector_copy_by_val(npc:position())
		pos.y = pos.y + 0.5
	end

	return pos
end

function is_level_changing()
	local sim = alife()
	local act = game_graph():vertex(sim:actor().m_game_vertex_id)
	return act:level_id() ~= sim:level_id()
end

--------------------------------------switch---------------------------------------
function switch_online(id)
	if id == -1 then return end
	local sim = alife()
	if sim then
		sim:set_switch_online(id,true)
		sim:set_switch_offline(id,false)
	end
end

function switch_offline(id)
	local sim = alife()
	if sim then
		sim:set_switch_online(id,false)
		sim:set_switch_offline(id,true)
	end
end

-------------------
function angle_diff(a1, a2)
  local b1=a1:normalize()
  local b2=a2:normalize()
  local dotp=b1:dotproduct(b2)
  return utils.rad2deg(math.acos(dotp))
end

function sr(text,...)
	if not (text) then return end
	local i = 0
	local p = {...}
	local function sr(a)
		i = i + 1
		if (type(p[1]) == "userdata") then
			return "userdata"
		end
		return tostring(p[i])
	end
	return string.gsub(text,"%%s",sr)
end

-------------------------------------------------------- DEBUG FUNCTION -------------------------------------------------
function debug_nearest(npc,msg,...)
	if (npc and xrs_debug_tools.NEAREST_STALKER and npc:id() == xrs_debug_tools.NEAREST_STALKER:id()) then
		alun_utils.printf("nearest=%s |"..msg,npc:name(),...)
	end
end 
function printf(msg,...)
	if not (msg) then return end
	local fmt = tostring(msg)

	if (select('#',...) >= 1) then
		local i = 0
		local p = {...}
		local function sr(a)
			i = i + 1
			if (type(p[i]) == 'userdata') then
				return 'userdata'
			end
			return tostring(p[i])
		end
		fmt = string.gsub(fmt,"%%s",sr)
	end
	get_console():execute("load ~#debug msg:"..fmt)
	--get_console():execute("flush")
	debug_write(fmt,true)
end

local debug_file
function debug_write(output,trace)
	if not (dev_debug) then
		return
	end

	if (trace and debug and type(debug.traceback) == 'function') then
		output = output .. debug.traceback('\n', 2)
	end

	if (last_ouput == output) then
		return
	end
	last_ouput = output

	if not (debug_file) then
		debug_file = io.open("axr_debug_log.txt","w+")
		debug_file:write(output.."\n")
		debug_file:close()
		debug_file = io.open("axr_debug_log.txt","a+")
	else
		debug_file:write(output.."\n")
	end

end

function str_format(str,...)
	if not (str) then
		return
	end
	local p = {...}
	local rep
	local new_str = ""
	for k,v in pairs(p) do
		rep = str_explode(v,"=")

		if (rep[1] and rep[2]) then
			str = str:gsub("("..tostring(rep[1])..")",tostring(rep[2]))
		end
	end
	return str
end

function is_trader(...)
	local p = {...}
	if p[1]:character_community() == "trader" or p[1]:clsid() == clsid.script_trader or p[1]:clsid() == clsid.trader then
		return true
	end

	if string.find(p[1]:section(),"trader") then
		return true
	end

	local cini = db.storage[p[1]:id()].ini
	local logic = db.storage[p[1]:id()].section_logic

	if not logic and not trader then
		return false
	end

	if cini and logic and cini:section_exist(logic) and cini:line_exist(logic,"trade") then
		return true
	end

	return false
end

function string_to_vector(str)
	local t = alun_utils.str_explode(str,",")
	return vector():set(tonumber(t[1]),tonumber(t[2]),tonumber(t[3]))
end

function vector_to_string(vec)
	return vec.x..","..vec.y..","..vec.z
end

function print_packet_data(data)
	local msg = ""
	for kk, vv in pairs(data) do
		if (type(vv) == "userdata" and vv.x and vv.y and vv.z) then
			--m.debug_write("%s: vector:= %s",kk,vec_to_str(vv))
			printf("%s: vector:= %s",kk,vec_to_str(vv))
			msg = msg.."["..kk.."] = "..vector_to_string(vv)
		else
			--m.debug_write("[%s] = %s",kk,vv)
			printf("[%s] = %s",kk,vv)
		end
	end
end

function set_squad_relation(npc,target,rel)
	if not (npc) then
		return
	end

	local squad = get_object_squad(npc)
	if not ( squad ) then
		return
	end

	for k in squad:squad_members() do
		local member = db.storage[k.id] and db.storage[k.id].object
		if ( member and member:alive() ) then
			member:set_relation(rel,target)
		end
	end
end

function set_squad_relation_to_squad(npc,target,rel)
	if not (npc) then
		return
	end

	local squad = get_object_squad(npc)
	if not ( squad ) then
		return
	end

	for k in squad:squad_members() do
		local member = db.storage[k.id] and db.storage[k.id].object
		if ( member and member:alive() ) then
			set_squad_relation(target,member,rel)
			set_squad_relation(member,target,rel)
		end
	end
end

function rand_num(a,b)
	local rnd = math.random
	if (a and b) then
		return rnd(a,b)
	end
	return rnd()
end

function create_squad(section,smart_name)
	local sim = sim_board.get_sim_board()
	if not (sim) then return end
	local smart = sim.smarts_by_names[smart_name]
	if not (smart) then
		alun_utils.printf("create_squad: no smart by name %s",smart_name)
		return
	end
	local squad = sim:create_squad(smart,section)
	squad.scripted_target = smart_name
	return squad
end

function assign_squad_to_smart(squad_id, id)
	local sim = sim_board.get_sim_board()
	if not (sim) then return end
	local squad = alife():object(squad_id)
	if not (squad) then return end
	if (squad.smart_id) then
		sim:exit_smart(squad,squad.smart_id)
	end
	sim:assign_squad_to_smart(squad,id)
	sim:enter_smart(squad,id)
	squad.assigned_target_id = id
	squad.current_action = nil
	squad:get_next_action(false)
end

function get_commander(npc)
	local squad = npc and get_object_squad(npc)
	if (squad and squad:commander_id()) then
		return level.object_by_id(squad:commander_id())
	end
end

function get_squad_commander_action(npc)

	local commander = get_commander(npc)
	local mgr = commander and commander:motivation_action_manager()
	if (mgr and mgr:initialized()) then
		return mgr:current_action_id()
	end
end

function collect_section(ini,section,keytable)
	if not (ini) then
		return
	end

	local _t = {}
	if ini:section_exist(section) then
		local n = ini:line_count(section)
		if n > 0 then
			for i = 0,n-1 do
				local res,id,val = ini:r_line(section,i,"","")
				if (keytable) then
					if (val == "") then
						val = true
					end
					_t[id] = val or true
				else
					table.insert(_t,id)
				end
			end
		end
	end
	return _t
end

function get_vertex(npc,dist)
	local rnd1,ang = math.random(100)
	if rnd1 < 43 then
		ang = math.random(50,60)
	elseif rnd1 < 58 then
		ang = math.random(160,200)
	else
		ang = math.random(300,310)
	end
	local dir = vector_rotate_y(npc:direction(),ang)
	return npc:vertex_in_direction(npc:level_vertex_id(),dir,dist)
end


function in_los(npc,friend,be)

	if (friend:id() ~= 0 and npc:target_body_state() ~= move.crouch and IsStalker(friend) and state_mgr.get_state(friend) ~= "prisoner") then
		if (friend:target_body_state() == move.crouch or xr_wounded.is_wounded(friend)) then 
			return false 
		end	
	end

	local pos = npc:bone_position("bip01_spine")
	local friend_pos = alun_utils.safe_bone_pos(friend,"bip01_spine")
	local friend_dist = pos:distance_to(friend_pos)
	local be_pos = alun_utils.safe_bone_pos(be,"bip01_spine")
	local dir_aim = be_pos:sub(pos)
	local be_dist = npc:position():distance_to(be:position())

	if (friend_dist < be_dist) then
		local dir_friend = utils.vector_copy_by_val(friend_pos):sub(pos)
		local vec_be,vec_who = utils.vector_copy_by_val(dir_aim):set_length(friend_dist),dir_friend:set_length(friend_dist)
		local mywho = friend_dist < 1.5 and vec_who:similar(vec_be,0) or vec_who:similar(vec_be,1.3)
		if (mywho == 1) then
			return true
		end
	end
	return false
end

function squad_in_los(npc,enemy)
	local squad = get_object_squad(npc)
	if not (squad) then
		return false
	end

	for o in squad:squad_members() do
		local member = db.storage[o.id] and db.storage[o.id].object
		if (member and member:alive()) then
			if (in_los(npc,member,enemy)) then
				return true
			end
		end
	end

	return false
end

function in_crosshair()
	local active_slot = db.actor:active_slot()
	if active_slot == 2 or active_slot == 3	then
		local active_item = db.actor:active_item()
		if active_item and isWeapon( active_item ) then
			for id,st in pairs(db.storage) do
				npc = st.object
				if (npc and (IsStalker(npc) or IsMonster(npc)) and npc:alive()) then
					local c = utils.vector_copy_by_val(npc:position())
					local p = db.actor:position()
					local d = device().cam_dir

					local vpc = vector():sub( c, p )
					
					if vpc:dotproduct( d ) > 0 then	 -- facing right direction
						
						local vec_c = vector():sub( c, p )
						vec_c = vector_rotate_y( vpc, 7 ) -- correct a little bit

						local vec_p = d
						--vec_p:normalize()
						
						local temp1 = vec_p:dotproduct( vec_c ) / ( vec_p:magnitude() )
						
						local temp2 = vec_p
						temp2.x = temp2.x * temp1
						temp2.y = temp2.y * temp1
						temp2.z = temp2.z * temp1
						
						local pc_temp = temp2
													
						local pc = vector():add( p, pc_temp )
															
						local ppp = vector():sub( c, pc )

						if ppp:magnitude() < 0.5 then
							return npc
						end
					end
				end
			end
		end 
	end
end

class "fake_squad"
function fake_squad:__init(se_obj)
	local squad = se_obj.parent_id ~= 65535 and alife():object(se_obj.parent_id)
	self.id = squad and squad.id or se_obj.id
	self.player_id = squad and squad.player_id
end

function fake_squad:am_i_reached(target)

end

function fake_squad:on_reach_target(squad)

end

function fake_squad:on_after_reach_target(squad)

end

function fake_squad:target_precondition(target)
	local squad_params = target.player_id and sim_board.simulation_activities[target.player_id]
	if squad_params == nil or squad_params.squad == nil then
		return false
	end

	local squad = alife():object(self.id)
	local self_params = squad_params.squad[self.player_id]
	if self_params == nil or self_params.prec(target, squad) == false then
		return false
	end
	return true
end


function npc_in_cover(npc)
	local st = get_storage(npc:id(),"in_cover")
	local tg = time_global()
	if (st.wait or 0) < tg then
		st.wait = tg+300
		local be = npc:best_enemy()
		local enemies = {}
		if be and not xr_wounded.is_wounded(be) then
			enemies[1] = be
		else
--			rx_ai.printf("npc_in_cover[%s]:not be",npc:character_name())
			st.evn = true
			return st.evn
		end
		if IsMonster(be) then
			local bee = be:get_enemy()
			if bee and bee:id() == npc:id() then
				st.evn = false
				return st.evn
			end
		end
		local tt = {}
		for o in npc:memory_visible_objects() do
			local obj = o:object()
			local id = obj:id()
			if obj and obj:alive() and npc:relation(obj) == game_object.enemy and (IsStalker(obj) or IsMonster(obj) or obj:id() == 0) and not xr_wounded.is_wounded(obj) then
--				rx_ai.printf("npc_in_cover[%s]:add enemy[%s]",npc:character_name(),obj:name())
				table.insert(enemies,obj)
				tt[id] = true
			end
		end
		for o in npc:memory_sound_objects() do
			local obj = o:object()
			local id = obj:id()
			if not tt[id] then
				if obj and obj:alive() and npc:relation(obj) == game_object.enemy and (IsStalker(obj) or IsMonster(obj) or obj:id() == 0) and not xr_wounded.is_wounded(obj) then
--					rx_ai.printf("npc_in_cover[%s]:add enemy[%s]",npc:character_name(),obj:name())
					table.insert(enemies,obj)
				end
			end
		end
		for i,enemy in ipairs(enemies) do
			local dist = npc:position():distance_to_sqr(enemy:position())
			local seez = enemy:see(npc) or npc:see(enemy)
			local dir,cover = enemy:position():sub(npc:position())
			if npc:body_state() == move.crouch then
				 cover = level.low_cover_in_direction(npc:level_vertex_id(),dir)
			else
				 cover = level.high_cover_in_direction(npc:level_vertex_id(),dir)
			end
			if dist < 25 or (seez and (dist < 80 or cover > 0.4 or (cover > 0.2 and dist < 600))) then
--				rx_ai.printf("npc_in_cover[%s]:enemy![dist = %s,seez = %s,cover = %s]",npc:character_name(),dist,tostring(seez),cover)
				st.evn = false
				st.wait = tg+2000
				return st.evn
			end
		end
		st.evn = true
	end
	return st.evn
end

--------------------------------------addons---------------------------------------
function get_addon_status(wpn,addon)
	if addon == "sc" then
		return wpn:weapon_scope_status()
	elseif addon == "sl" then
		return wpn:weapon_silencer_status()
	elseif addon == "gl" then
		return wpn:weapon_grenadelauncher_status()
	end
	return 0
end

local rep_mem = {}

function get_addon_flag(wpn,with_int)
		local flag = 0
		if wpn:weapon_is_scope() then
			if with_int or get_addon_status(wpn,"sc") == 2 then
				flag = 1
			end
		end
		if wpn:weapon_is_silencer() then
			if with_int or get_addon_status(wpn,"sl") == 2 then
				flag = flag+4
			end
		end
		if wpn:weapon_is_grenadelauncher() then
			if with_int or get_addon_status(wpn,"gl") == 2 then
				flag = flag+2
			end
		end
		return flag
	end

function addon_attached(wpn,addon,flag)
	local ft = {sc = {[1] = true,[3] = true,[5] = true,[7] = true},
				sl = {[4] = true,[5] = true,[6] = true,[7] = true},
				gl = {[2] = true,[3] = true,[6] = true,[7] = true}}
	if ft[addon] then
		return ft[addon][flag or get_addon_flag(wpn,true)] == true
	end
	return false
end

--******************
-- Storage from Rulix
--******************

function get_storage(id,name)
	if not id then
		return
	end
	local st = db.storage[id]
	if not st then
		local obj = level.object_by_id(id)
		local name = "uk"
		if obj then
			name = obj:character_name()
		end
		--printf("get_storage[%s:%s]:not npc storage! (%s)",id,name,tostring(name))
		return {}
	end
	if not st.ai_tweaks then
		st.ai_tweaks = {}
	end
	if not name then
		return st.ai_tweaks
	end
	if not st.ai_tweaks[name] then
		st.ai_tweaks[name] = {}
	end
	return st.ai_tweaks[name]
end

weapon_types_clslist = {
pistol = {[clsid.wpn_pm_s] = true,[clsid.wpn_walther_s] = true,[clsid.wpn_usp45_s] = true,[clsid.wpn_hpsa_s] = true,[clsid.wpn_lr300_s] = true},
sniper = {[clsid.wpn_svu_s] = true,[clsid.wpn_svd_s] = true,[clsid.wpn_vintorez_s] = true},
launcher = {[clsid.wpn_rg6_s] = true,[clsid.wpn_rpg7_s] = true},
shotgun = {[clsid.wpn_shotgun_s] = true,[clsid.wpn_auto_shotgun_s] = true},
rifle = {[clsid.wpn_ak74_s] = true,[clsid.wpn_groza_s] = true,[clsid.wpn_val_s] = true},
double_barreled = {[clsid.wpn_bm16_s] = true},
knife = {[clsid.wpn_knife_s] = true}}

function isPistol(wpn,clsid)
	if not (clsid) then
		clsid = wpn:clsid()
	end
	return weapon_types_clslist.pistol[clsid]
end

function isSniper(wpn,clsid)
	if not (clsid) then
		clsid = wpn:clsid()
	end
	return weapon_types_clslist.sniper[clsid]
end

function isLauncher(wpn,clsid)
	if not (clsid) then
		clsid = wpn:clsid()
	end
	return weapon_types_clslist.launcher[clsid]
end

function isShotgun(wpn,clsid)
	if not (clsid) then
		clsid = wpn:clsid()
	end
	return weapon_types_clslist.shotgun[clsid] or weapon_types_clslist.double_barreled[clsid]
end

function isRifle(wpn,clsid)
	if not (clsid) then
		clsid = wpn:clsid()
	end
	return weapon_types_clslist.rifle[clsid]
end

--***************************************
--* save_var(game_object,name,value)
--* load_var(game_object,name,def_value)
--*--------------------------------------
--* Stores/Loads variable with xr_logic's
--* pstor functions.
--***************************************
function save_var(npc,var,val)
	xr_logic.pstor_store(npc,var,val)
	return val
end

function load_var(npc,var,def)
	return xr_logic.pstor_retrieve(npc,var,def)
end

--**********************************************************************************************************************************
--* Staging! Makes stepping or staging within userobj (class) functions a breeze!
--*---------------------------------------------------------------------------------------------------------------------------------
--*	get_stage(userobj)			--> Returns current stage
--* set_stage(userobj,value)	--> sets current stage
--* next_stage(userobj)			--> goto next stage
--**********************************************************************************************************************************
function get_stage(userobj)
	if (userobj.stage == nil) then
		userobj.stage = 0
	end
	return userobj.stage
end
function set_stage(userobj,value)
	if ( userobj.stage ) then
		userobj.stage = value
		return true
	end
	return false
end
function next_stage(userobj)
	if ( userobj.stage ) then
		userobj.stage = userobj.stage + 1
		return true
	end
	return false
end

--**********************************************************************************************************************************
--* Timing! Makes running userobj functions take up less cpu time if only needed to be ran on a certain time
--*---------------------------------------------------------------------------------------------------------------------------------
--*	set_timer(userobj,value)	--> sets timer to time_global() + value
--* set_stage(userobj,value)	--> gets timer flag. Nil for empty, 1 for expired and -1 for on going
--**********************************************************************************************************************************
function set_timer(userobj, time)
	if not ( userobj ) then
		return
	end
	userobj.timer = time_global() + time
end

function get_timer(userobj)
	if ( userobj.timer ~= nil ) then
		if ( time_global() > userobj.timer ) then
			userobj.timer = nil
			return 1
		else
			return -1
		end
	end
	return nil
end

local exec_queue = {}
local exec_data = {}
local remove_me = {}
function execute_queue()
	local id
	local se_obj
	local sim = alife()

	for i=#exec_queue, 1, -1 do
		id = exec_queue[i]
		se_obj = id and sim:object(id)
		if not (se_obj) then
			-- object no longer exists
			exec_data[id] = nil
			table.insert(remove_me,i)
		end

		if not (se_obj.online) then
			-- execute function and switch online
			--alun_utils.printf("offline execute 1")
			exec_data[id].f(se_obj,exec_data[id].p)
			exec_data[id] = nil
			table.insert(remove_me,i)

			local parent = se_obj.parent_id ~= 65535 and alife():object(se_obj.parent_id)
			if (parent and not exec_data[se_obj.parent_id]) then
				parent:switch_online()
			else
				se_obj:switch_online()
			end
			--alun_utils.printf("offline execute 2")
		else
			local obj = level.object_by_id(id)
			if (IsStalker(se_obj)) then
				if (obj) then
					if (not db.actor:see(obj) or (alun_utils.angle_diff(db.actor:direction(), db.actor:position():sub(obj:position()))<90 and obj:position():distance_to(db.actor:position()) > 2.5) or obj:position():distance_to(db.actor:position())>100) then
						se_obj:switch_offline()
					end
				end
			else
				--[[
				local parent = se_obj.parent_id ~= 65535 and alife():object(se_obj.parent_id)
				if (parent and not exec_data[parent.id]) then
					if (IsStalker(parent)) then
						local obj = level.object_by_id(parent.id)
						if (not db.actor:see(obj) or (alun_utils.angle_diff(db.actor:direction(), db.actor:position():sub(obj:position()))<90 and obj:position():distance_to(db.actor:position()) > 2.5) or obj:position():distance_to(db.actor:position())>100) then
							parent:switch_offline()
						end
					else
						parent:switch_offline()
					end
				else
					se_obj:switch_offline()
				end
				--]]
				local parent = se_obj.parent_id ~= 65535 and alife():object(se_obj.parent_id)
				if (parent and not exec_data[se_obj.parent_id]) then
					parent:switch_offline()
				else
					se_obj:switch_offline()
				end
			end
		end
	end

	for i=#remove_me,1,-1 do
		table.remove(exec_queue,remove_me[i])
		table.remove(remove_me,i)
	end
end

function switch_offline_execute(id,func,...)
	if not (exec_data[id]) then
		exec_data[id] = {}
		exec_data[id].f = func
		exec_data[id].p = {...}
		table.insert(exec_queue,id)
	end
end

--**********************************************************************************************************************************
--* memoize(function)		--> Memoizies a function with a weak table
--**********************************************************************************************************************************
function memoize (f)
	local mem = {} -- memoizing table
	setmetatable(mem, {__mode = "kv"}) -- make it weak
	return function (x) -- new version of ’f’, with memoizing
	local r = mem[x]
		if r == nil then -- no previous result?
			r = f(x) -- calls original function
			mem[x] = r -- store result for reuse
			end
		return r
	end
end

--local loadstring = memoize(loadstring)


---------------------------------------- Path Nodes
class "position_node"
function position_node:__init(amt)
	self.node = {}
	for i=1,amt do
		self.node[i] = {}
	end
end

function position_node:select_best_vertex_id(object,dir,lvid,distance)
	local closest
	for i=1, #self.node do
		if	(bit_and(i,1)) then
			self.node[i].desired_direction = vector_rotate_y(dir, -math.random(50,60))
		else
			self.node[i].desired_direction = vector_rotate_y(dir, math.random(50,60))
		end

		self.node[i].vertex_id = level.vertex_in_direction(lvid, self.node[i].desired_direction, distance)

		if (self.node[i].vertex_id and accessible(object,self.node[i].vertex_id)) then
			self.node[i].distance = self.node[i].vertex_id == lvid and -1 or object:position():distance_to_sqr(level.vertex_position(self.node[i].vertex_id))

			if not (closest) then
				closest = self.node[i].vertex_id
			end

			if (self.node[i-1] and self.node[i-1].distance < self.node[i].distance) then
				closest = self.node[i-1].vertex_id
			end
		end
	end
	return closest and closest ~= -1 and closest
end

-------------------------------------------- INI utils

-- INI Reader
function file_to_table(fname,dir)
	local root = {}
	local includes
	local sec_includes
	local sec, t,_root,key,val
	for line in io.lines(fname) do
		if not (line == "" or line == "\n") then
			if (startsWith(line, "#include")) then
				t = str_explode(line,";")
				t = str_explode(t[1],[["]])

				if not (includes) then
					includes = {}
				end

				table.insert(includes,t[2])
				_root = file_to_table(dir..t[2])
				for k,v in pairs(_root) do root[k] = v end
			elseif (startsWith(line, "[")) then
				t = str_explode(line,";")
				t = str_explode(t[1],":")

				sec = string.sub(t[1],2,-2)
				root[sec] = {}

				if (t[2]) then
					if not (sec_includes) then
						sec_includes = {}
					end

					sec_includes[sec] = str_explode(t[2],",")
				end
			elseif (not startsWith(line, ";")) then
				t = str_explode(line,";")
				key = string.match(t[1],"(.-)=") or t[1]
				if (key) then
					key = trim(key)
					val = string.match(t[1],"=(.+)")
					if (val) then
						val = trim(val)
					end

					if (sec) then
						root[sec] = root[sec] or {}
						root[sec][key] = val or ""
					else
						root[key] = val or ""
					end
				else
					printf("file_to_table: Unable to process key in section %s. key=%s",sec,key)
				end
			end
		end
	end

	if (sec_includes) then
		for section,tbl in pairs(sec_includes) do
			if (type(tbl) == "table") then
				for i=1,#tbl do
					for key,val in pairs(root[tbl[i]]) do
						root[section][key] = val
					end
				end
			end
		end
	end

	return root,includes
end

class "cfg_file"
function cfg_file:__init(fname)
	--alun_utils.printf("fname=%s",fname)
	local cfg = io.open(fname,"a+")
	cfg:close()
	self.fname = fname
	self.directory = string.match(fname,"(.%S+\\)") or ""
	self.root,self.includes = file_to_table(fname,self.directory)
end

function cfg_file:GetValue(sec,key,typ,def)
	local val = self.root and self.root[sec] and self.root[sec][key]
	if (val == nil) then
		return def
	end

	if (typ == 1 or typ == "bool") then
		return val == "true"
	elseif (typ == 2 or typ == "number") then
		return tonumber(val)
	end
	return val
end

function cfg_file:GetKeys(sec)
	return self.root and self.root[sec]
end

function cfg_file:SetValue(sec,key,val)
	if not (self.root) then
		self.root = {}
	end

	if not (self.root[sec]) then
		self.root[sec] = {}
	end

	self.root[sec][key] = val == nil and "" or tostring(val)
end

function cfg_file:SectionExist(sec)
	return self.root and self.root[sec] ~= nil
end

function cfg_file:KeyExist(sec,key)
	return self.root and self.root[sec] and self.root[sec][key] ~= nil
end

-- Save ini by preserving original file. Cannot insert new keys or sections
function cfg_file:SaveExt()
	local t,sec,comment
	local str = ""
	for ln in io.lines(self.fname) do
		ln = trim(ln)
		if (startsWith(ln,"[")) then
			t = str_explode(ln,";")
			t = str_explode(t[1],":")

			sec = string.sub(t[1],2,-2)
		elseif (not startsWith(ln,";") and self.root[sec]) then
			comment = string.find(ln,";")
			comment = comment and string.sub(ln,comment) or ""

			t = str_explode(ln,"=")
			if (self.root[sec][t[1]] ~= nil) then
				if (self.root[sec][t[1]] == "") then
					ln = t[1] .. "\t" .. comment
				else
					ln = t[1] .. " = " .. tostring(self.root[sec][t[1]]) .. "\t" .. comment
				end
			end
		end
		str = str .. ln .. "\n"
	end
	local cfg = io.open(self.fname,"w+")
	cfg:write(str)
	cfg:close()
end

-- Recreates ini as stored in the table
function cfg_file:Save()
	local str = "",count

	if (self.includes) then
		for i=1,#self.includes do
			str = str .. self.includes[i] .. "\n"
		end
	end

	for section,tbl in pairs(self.root) do
		str = str .. "[" .. section .. "]\n"

		if (self.links and self.links[section]) then
			str = str .. ":"
			count = #self.links[section]
			for i=1,count do
				if (count > 1 and i ~= count) then
					str = str .. self.links[section][i] .. ","
				else
					str = str .. self.links[section][i]
				end
			end
		end

		for key,val in pairs(self.root[section]) do
			if (val == nil or val == "") then
				str = str .. key .. "\n"
			else
				str = str .. key .. " = " .. tostring(val) .. "\n"
			end
		end
	end

	local cfg = io.open(self.fname,"w+")
	cfg:write(str)
	cfg:close()
end

function startsWith(text,prefix)
	return string.sub(text, 1, string.len(prefix)) == prefix
end

function w_stpk(stpk,typ,n,info)
	local isError

	if (typ == "bool") then
		if (n and type(n) == "boolean") then
			stpk:w_bool(n)
		elseif (n and type(n) == "string") then
			isError = true
			if (n == "true") then
				stpk:w_bool(true)
			elseif (n == "false") then
				stpk:w_bool(false)
			end
			info = info .. " |-> auto-corrected bool value from string"
		else
			if (n) then
				isError = true
			end
			stpk:w_bool(false)
		end

	elseif (typ == "s8") then
		if (n and type(n) == "number" and n >= -128 and n <= 128) then
			stpk:w_s8(n)
		else
			isError = true
			stpk:w_s8(0)
		end

	elseif (typ == "s16") then
		if (n and type(n) == "number" and n >= -32768 and n <= 32767) then
			stpk:w_s16(n)
		else
			isError = true
			stpk:w_s16(0)
		end

	elseif (typ == "s32") then
		if (n and type(n) == "number" and n >= -2147483648 and n <= 2147483647) then
			stpk:w_s32(n)
		else
			isError = true
			stpk:w_s32(0)
		end

	elseif (typ == "s64") then
		if (n and type(n) == "number" and n >= -9223372036854775808 and n <= 9223372036854775808) then
			stpk:w_s64(n)
		else
			isError = true
			stpk:w_s64(0)
		end

	elseif (typ == "u8") then
		if (n and type(n) == "number" and n >= 0 and n <= 255) then
			stpk:w_u8(n)
		else
			isError = true
			stpk:w_u8(0)
		end

	elseif (typ == "u16") then
		if (n and type(n) == "number" and n >= 0 and n <= 65535) then
			stpk:w_u16(n)
		else
			isError = true
			stpk:w_u16(0)
		end

	elseif (typ == "u32") then
		if (n and type(n) == "number" and n >= 0 and n <= 4294967295) then
			stpk:w_u32(n)
		else
			isError = true
			stpk:w_u32(0)
		end

	elseif (typ == "u64") then
		if (n and type(n) == "number" and n >= 0 and n <= 18446744073709551615) then
			stpk:w_u64(n)
		else
			isError = true
			stpk:w_u64(0)
		end

	elseif (typ == "float") then
		if (n and type(n) == "number") then
			stpk:w_float(n)
		else
			isError = true
			stpk:w_float(0)
		end

	elseif (typ == "stringZ") then
		if (n and type(n) == "string") then
			if (string.len(n) > 255) then
				isError = true
				info = info .. " |-> length of string is too long for stringZ"
			end
			stpk:w_stringZ( string.sub(n,0,255) )
		elseif (n and type(n) ~= "userdata") then
			stpk:w_stringZ(tostring(n))
		else
			--isError = true
			stpk:w_stringZ("nil")
		end

	elseif (typ == "CTime") then
		if (n and type(n) == "userdata" and n.timeToString) then
			utils.w_CTime(stpk,n)
		else
			--printf("w_stpk:Debug: CTime is nil [%s]",info)
			utils.w_CTime(stpk,nil)
		end
	else
		isError = true
	end

	if (isError) then
		printf("w_stpk:CRITICAL ERROR: write %s (%s) TrueType=%s [%s]   | Packet:w_tell()=>%s",typ,type(n) ~= "userdata" and tostring(n) or "userdata",type(n),info,stpk:w_tell())
	else
		--printf("w_stpk:DEBUG: write %s (%s) TrueType=%s [%s]   | Packet:w_tell()=>%s",typ,type(n) ~= "userdata" and tostring(n) or "userdata",type(n),info,stpk:w_tell())
	end
end

function findfunction(x,tbl)
	assert(type(x) == "string")
	local f=tbl
	for v in x:gmatch("[^%.]+") do
		if type(f) ~= "table" then
			printf("looking for '%s' expected table, not %s",v,type(f))
			return
		end
		f=f[v]
	end
	if type(f) == "function" then
		return f
	else
		printf("expected function, not %s",type(f))
		return nil
	end
end

local fsgame
function get_fsgame()
	if (fsgame) then
		return fsgame
	end

	local root = file_to_table("fsgame.ltx")

	local fsgame = {}
	fsgame["$fs_root$"] = ""
	local t
	for k,v in pairs(root) do
		t = str_explode(v,"|")
		dir = t[3]
		fsgame[k] = t[4] or ""
		repeat
			t = root[dir] and str_explode(root[dir],"|")
			dir = t and t[3]
			fsgame[k] = (t and t[4] or "") .. fsgame[k]
		until (dir == nil)
	end
	return fsgame
end

function fspath(str)
	local fsg = get_fsgame()
	return fsg[str] or ""
end

function fsgame_append(str,ap)
	if (fspath(str) ~= "" and fspath(str) ~= nil) then
		return
	end
	fsgame = nil

	local fsg = io.open("fsgame.ltx","a+")
	local data = fsg:read("*all")
	if not (string.find(data,str)) then
		fsg:write("\n"..ap)
	end
	fsg:close()
end

function CTime2table(gt)
	if not (gt) then
		return
	end

	local t = {}
	t.y, t.m, t.d, t.h, t.m, t.s, t.ms = 0, 0, 0, 0, 0, 0, 0
	t.y, t.m, t.d, t.h, t.m, t.s, t.ms = gt:get( t.y, t.m, t.d, t.h, t.m, t.s, t.ms )
	t.y = t.y - 2000
	return t
end

function table2CTime(t)
	if not (t and t.y and t.m and t.d and t.h and t.m and t.s and t.ms) then
		return
	end

	local gt = game.CTime()
	gt:set( t.y + 2000,  t.m, t.d, t.h, t.m, t.s, t.ms)
	return gt
end

function find_random_cover(npc,pos,min_rad,max_rad)
	local rand = math.random
	local base_point = npc:level_vertex_id()
	local base_vertex_id = level.vertex_in_direction(base_point, vector_rotate_y(utils.vector_copy_by_val(npc:direction()),rand(-90,90)), rand(min_rad,max_rad))
	local base_position = level.vertex_position(base_vertex_id)

	local cover, tcover
	local cover_dist = rand(1,30)
	while not cover and cover_dist > 0 do
		cover = npc:best_cover(base_position,pos,cover_dist,1,150)
		cover_dist = cover_dist - 1
	end

	return cover and (tcover and tcover.cover_vertex_id or cover:level_vertex_id()) or base_vertex_id
end

function find_close_cover(npc,base_position,pos,cover_dist)
	local cover, tcover
	cover_dist = not cover_dist and 5 or cover_dist
	while not cover and cover_dist < 30 do
		cover = npc:best_cover(base_position,pos,cover_dist,1,30)
		cover_dist = cover_dist + 2
	end
	
	return cover and (tcover and tcover.cover_vertex_id or cover:level_vertex_id())
end

function find_cover_in_direction(npc,base_point,pos,dir,min_rad,max_rad)
	local rand = math.random
	local base_vertex_id = level.vertex_in_direction(base_point,dir,rand(min_rad,max_rad))
	local base_position = level.vertex_position(base_vertex_id)

	local cover, tcover
	local cover_dist = rand(1,30)
	while not cover and cover_dist > 0 do
		cover = npc:best_cover(base_position,pos,cover_dist,1,150)
		cover_dist = cover_dist - 1
	end

	return cover and (tcover and tcover.cover_vertex_id or cover:level_vertex_id()) or base_vertex_id
end

function sqrMagnitude(vec)
	return (vec.x^2)+(vec.y^2)+(vec.z^2) 
end

--[[
class "BezierPath"
function BezierPath:__init() 
	self.SEGMENTS_PER_CURVE = 10
	self.MINIMUM_SQR_DISTANCE = 0.01
	self.DIVISION_THRESHOLD = -0.99
	self.controlPoints = {}
	self.curveCount = 0
end 

-- Sets the control points of this Bezier path.
-- Points 0-3 forms the first Bezier curve, points 
-- 3-6 forms the second curve, etc.
function BezierPath:SetControlPoints(newControlPoints)
	empty_table(self.controlPoints)
	self.controlPoints = newControlPoints
	self.curveCount = (#self.controlPoints-1)/3
end 

-- returns the control points for this Bezier curve
function BezierPath:GetControlPoints()
	return self.controlPoints
end

-- Calculates a Bezier interpolated path for the given points.
function BezierPath:Interpolate(segmentPoints,scale)
	empty_table(self.controlPoints)
	
	if (#segmentPoints < 2) then 
		return 
	end
	
	for i=1, #segmentPoints, 1 do 
		if (i == 1) then 
			local p1 = segmentPoints[i]
			local p2 = segmentPoints[i+1]
			
			local tangent = vector():sub(p2,p1)
			local q1 = p1:add(tangent:mul(scale))
			
			table.insert(self.controlPoints,p1)
			table.insert(self.controlPoints,q1)
		elseif (i == #segmentPoints) then
			local p0 = segmentPoints[i]
			local p1 = segmentPoints[i+1]
			
			local tangent = vector():sub(p1,p0)
			local q0 = p1:add(tangent:mul(scale))
			
			table.insert(self.controlPoints,q0)
			table.insert(self.controlPoints,p1)
		else
			local p0 = segmentPoints[i-1]
			local p1 = segmentPoints[i]
			local p2 = segmentPoints[i+1]
			
			local tangent = vector():sub(p2,p0):normalize()
			
			local q0 = vector():sub(p1,tangent:mul(scale):mul( vector():sub(p1,p0):magnitude() ))
			local q1 = vector():add(p1,tangent:mul(scale):mul( vector():sub(p2,p1):magnitude() ))
			
			table.insert(self.controlPoints,q0)
			table.insert(self.controlPoints,p1)
			table.insert(self.controlPoints,q1)
		end
	end
	self.curveCount = (#self.controlPoints-1)/3
end

-- Sample the given points as a Bezier path.
function BezierPath:SamplePoints(sourcePoints,minSqrDistance,maxSqrDistance,scale)
	if (#sourcePoints < 2) then 
		return 
	end 
	
	local samplePoints = {}
	table.insert(sourcePoints[1])
	
	local potentialSamplePoint = sourcePoints[2]
	
	for i=3, #sourcePoints, 1 do 
		if ( sqrMagnitude(vector():sub(potentialSamplePoint,sourcePoints[i])) > minSqrDistance ) then 
			if ( sqrMagnitude(vector():sub(samplePoints[#samplePoints],sourcePoints[i])) > maxSqrDistance ) then 
				table.insert(samplePoints,potentialSamplePoint)
			end		
		end 
		potentialSamplePoint = sourcePoints[i]
	end
	
	-- now handle last bit of curve
	local p1 = samplePoints[#samplePoints]
	samplePoints[#samplePoints] = nil 
	
	local p0 = samplePoints[#samplePoints]
	local tangent = vector():sub(p0,potentialSamplePoint):normalize()
	
	local d2 = vector():sub(potentialSamplePoint,p1):magnitude()
	local d1 = vector():sub(p1,p0):magnitude()
	
	p1 = vector():add(p1, tangent:mul((d1-d2/2)))
	
	table.insert(samplePoints,p1)
	table.insert(samplePoints,potentialSamplePoint)
	
	self:Interpolate(samplePoints,scale)
end 

-- Caluclates a point on the path.
--
-- @param curveIndex The index of the curve that the point is on. For example, 
-- the second curve (index 1) is the curve with controlpoints 3, 4, 5, and 6.
--
-- @param t The paramater indicating where on the curve the point is. 0 corresponds 
-- to the "left" point, 1 corresponds to the "right" end point.
function BezierPath:CalculateBezierPoint(curveIndex,t)
	local nodeIndex = curveIndex * 3

	local p0 = self.controlPoints[nodeIndex]
	local p1 = self.controlPoints[nodeIndex + 1]
	local p2 = self.controlPoints[nodeIndex + 2]
	local p3 = self.controlPoints[nodeIndex + 3]

	return self:CalculateBezierPoint(t, p0, p1, p2, p3)
end

-- Gets the drawing points. This implementation simply calculates a certain number
-- of points per curve

function BezierPath:GetDrawingPoints0()
	local drawingPoints = {}
	
	for curveIndex=1, self.curveCount, 1 do 
		if (curveIndex == 1) thne 
			table.insert(drawingPoints,CalculateBezierPoint(curveIndex,0))
		end
		for j=1, self.SEGMENTS_PER_CURVE, 1 do 
			local t = j/self.SEGMENTS_PER_CURVE
			table.insert(drawingPoints,self:CalculateBezierPoint(curveIndex,t))
		end
	end
	
	return drawingPoints
end

-- slightly different than above
function BezierPath:GetDrawingPoints1()
	local drawingPoints = {}
	
	for i=1, #self.controlPoints-3, 3 do 
		local p0 = self.controlPoints[nodeIndex]
		local p1 = self.controlPoints[nodeIndex + 1]
		local p2 = self.controlPoints[nodeIndex + 2]
		local p3 = self.controlPoints[nodeIndex + 3]
		
		if (i == 1) then 
			table.insert(drawingPoints,self:CalculateBezierPoint(0,p0,p1,p2,p3))
		end
		
		for j=1, SEGMENTS_PER_CURVE, 1 do 
			local t = j/SEGMENTS_PER_CURVE
			table.insert(CalculateBezierPoint(t,p0,p1,p2,p3))
		end
	end

	return drawingPoints
end

-- returns the number of points added.
function BezierPath:FindDrawingPoints(curveIndex,t0,t1,pointList,insertionIndex)
	local left = CalculateBezierPoint(curveIndex, t0)
	local right = CalculateBezierPoint(curveIndex, t1)
	
	if ( sqrMagnitude(vector():sub(left,right)) < self.MINIMUM_SQR_DISTANCE ) then 
		return 0
	end
	
	local tMid = (t0+t1)/2
	local mid = CalculateBezierPoint(curveIndex,tMid)
	
	local leftDirection = vector():sub(left,mid):normalize()
	local rightDirection = vector():sub(right,mid):normalize()
	
	if (leftDirection:dotproduct(rightDirection) > self.DIVISION_THRESHOLD or math.abs(tMid - 0.5) < 0.0001) then 
		local pointsAddedCount = 0
		
		pointsAddedCount = pointsAddedCount + self:FindDrawingPoints(curveIndex,t0,tMid,pointList,insertionIndex)
		table.insert(pointList,insertionIndex+pointsAddedCount,mid)
		pointsAddedCount = pointsAddedCount + 1 
		pointsAddedCount = pointsAddedCount + self:FindDrawingPoints(curveIndex,tMid,t1,pointList,insertionIndex+pointsAddedCount)
		return pointsAddedCount
	end
	
	return 0 
end 

-- Caluclates a point on the Bezier curve represented with the four controlpoints given.
function BezierPath:CalculateBezierPoint(t,p0,p1,p2,p3)
	local u = 1 - t
	local tt = t*t 
	local uu = u*u 
	local uuu = uu*u 
	local ttt = tt*t
	
	local p = utils.vector_copy_by_val(p0):mul(uuu)
	
	p:add( utils.vector_copy_by_val(p1):mul(uu*t) )
	p:add( utils.vector_copy_by_val(p2):mul(tt*u) )
	p:add( utils.vector_copy_by_val(p3):mul(ttt) )
	
	return p
end
--]]
