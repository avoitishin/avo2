--[[-- INFO -------------------------------------------------------------------
	File				: avo_timers
	Description	: Persistent (saved) timers
	Credits			: xStream, malandrinus, aVo
	Revision		: 0.1
	Change Date	: 08.04.2014
--]] --------------------------------------------------------------------------

--[[-- TODO -------------------------------------------------------------------
	1. Add HOWTO
--]]---------------------------------------------------------------------------

--/----------------------------------------------------------------------------
--/ Variables & Constants
--/----------------------------------------------------------------------------
local SELF_NAME = script_name()
-- timer types
local timer_type = {}
timer_type.game_time = 1 -- in game seconds
timer_type.real_time = 2 -- in real milliseconds

local timers_holder = {} -- all timers will be stored here
local closest_real = 0
local closest_game = 0
local loaded = false
--/----------------------------------------------------------------------------
--/ Initialization
--/----------------------------------------------------------------------------
function _init()
	local CFG_FILE = avo.MOD_FOLDER..SELF_NAME..".ltx"
	local ini = ini_file(CFG_FILE)
	if not ini then abort("[%s]: Falied to load configuration file [%s]", SELF_NAME, CFG_FILE) end
	
	slot("on_actor_update", this.check_timers)
	slot("on_actor_net_spawn", this.on_load)
	-- slot("on_actor_net_spawn", this.test)
	
	avo.timer = this.timer
	
	
	
	ini = nil
	wlog("%s is ready", SELF_NAME)
end

-- quick helper, replace with proper timer:dump function
function dump_timers()
	dlog(table.print(timers_holder))
end

--/----------------------------------------------------------------------------
--/ PRIVATE functions
--/----------------------------------------------------------------------------
--/----------------------------------------------------------------------------
--/ Get new timer ID
--/----------------------------------------------------------------------------
local function get_new_id()
	local i = 0
	for idx in ipairs(timers_holder) do
		i = idx
	end
	return i + 1
end
--/----------------------------------------------------------------------------
--/ Get max registered timer ID
--/----------------------------------------------------------------------------
local function get_max_id()
	local i = 0
	for idx in pairs(timers_holder) do
		if idx > i then
			i = idx
		end
	end
	return i
end

-- get real function from string, for ex: "avo.storage.save" will be parsed to ["avo"]["storage"]["save"]
-- need to remove this string function name parameter nonsense
local function get_real_function_by_name(cb_name)
	-- local tokens, obj = explode(".", cb_name), _G
	local tokens, obj = avo_lua.split(cb_name, "."), _G -- avo: temp until string.split clash is fixed
	for _, tok in ipairs(tokens) do
		if obj[tok] then
			obj = obj[tok]
		else -- something gone wrong
			return
		end
	end
	
	if type(obj)=='function' then
		return obj
	end
end

--/----------------------------------------------------------------------------
--/ Helper: triggers timer by ID
--/----------------------------------------------------------------------------
local function _trigger(idx)
	if not idx then
		return
	end
	
	timers_holder[idx]:trigger()
	if not timers_holder[idx].__once then
		timers_holder[idx]:rearm()
	else
		timers_holder[idx]:stop()
	end
end

--/----------------------------------------------------------------------------
--/ Triggers timers by ID and 
--/----------------------------------------------------------------------------
local function trigger_timer(idx)
	if not loaded then
		return
	end
	
	_trigger(idx)
	
	--find new closest timers
	closest_real = 0
	closest_game = 0
	local current_time = time_global()
	local current_game_time = game.time()
	local timers_to_trigger = {}
	local closest_real_time = 0
	local closest_game_time = 0
	
	for k,t in pairs(timers_holder) do
		if t.__type==timer_type.real_time then -- find realtime timers
			if t.__trigger_time <= current_time then -- may be this timer should trigger too?
				table.insert(timers_to_trigger, t.id)
			else -- find at least closest...
				if closest_real_time==0 or closest_real_time > t.__trigger_time then
					closest_real_time = t.__trigger_time
					closest_real = t.id
				end
			end
		else -- find game timers
			dlog("trigger_timer: current_game_time = %s, trigger_time = %s", current_game_time, t.__trigger_time)
			if t.__trigger_time <= current_game_time then -- may be this timer should trigger too?
				dlog("trigger_time is less: %s <= %s", t.__trigger_time, current_game_time)
				table.insert(timers_to_trigger, t.id)
			else -- find at least closest...
				if closest_game_time==0 or closest_game_time > t.__trigger_time then
					closest_game_time = t.__trigger_time
					closest_game = t.id
				end
			end
		
		end
	end
	
	for _, idx in ipairs(timers_to_trigger) do
		_trigger(idx)
	end
	
end

local prev_game_time = 0
-- events 
function check_timers()
	if table.size(timers_holder) == 0 then return end
	
	local current_time = time_global()
	local current_game_time = game.time()
	
	--check for date overflow
	if current_time < prev_game_time then
		-- local diff = prev_game_time - current_time
		local diff = prev_game_time - current_game_time
		dlog("diff = %s", diff)
		--find all game timers and reduce trigger time
		for k,t in pairs(timers_holder) do
			if t.__type==timer_type.game_time then -- find realtime timers
				t.__trigger_time = t.__trigger_time - diff
				t:__save()
			end
		end	
	end
	
	if timers_holder[closest_real] and timers_holder[closest_real].__trigger_time <= current_time then
		trigger_timer(closest_real)
	end
	if timers_holder[closest_game] and timers_holder[closest_game].__trigger_time <= current_game_time then
		dlog("about to trigger game time from check_timers")
		trigger_timer(closest_game)
	end
	prev_game_time = current_game_time
end

function on_load()
	local collected_timers = {}
	local max_id, timer_desc, t = avo.load("timers_last_id", 0)
	
	-- collect timers
	for k = 1, max_id do
		timer_desc = avo.load("timers_timer_"..k)
		dlog(table.print(timer_desc))
		if timer_desc then
			-- create timer and setup it
			t = timer()
			t.__callback = timer_desc.cb
			t.__callbackData = timer_desc.cbd
			t.__type = timer_desc.type
			t.__interval = tonumber(timer_desc.int)	
			t.__trigger_time = tonumber(timer_desc.when)
			t.__once = timer_desc.once
			table.insert(collected_timers, t)
			
			-- remove description
			avo.save("timers_timer_"..k, nil)
		end
	end
	
	-- clear info
	avo.save("timers_last_id", nil)
	
	-- run them all!
	for _,t in ipairs(collected_timers) do
		t:__run()
	end
	
	loaded = true

	trigger_timer()
end

---- example
--function test()
--	-- skip second run
--	dlog("in test")
--	if get_max_id()>0 then
--		return
--	end
--	
--	local t = timer()
--	t:setCallback("avo_timers.kill_npc")
--	t:setCallbackData({ id = db.actor:id() })
--	t:runReal(60*1000)
--	dlog("timer set")
--end
--
--function kill_npc(data)
--	dlog("in kill_npc")
--	local cobj = level.object_by_id(data.id or 0)
--	
--	if cobj then
--		cobj:kill(cobj)
--	end
--end
--====================================================--

-- public members

--function init()
--	-- translate to global namespace
--	_G.timer = timer
--	
--	event("actor_update"):register(check_timers)
--	event("actor_spawn"):register(on_load)
--	--event("actor_spawn"):register(test)
--end

--====================================================--
class "timer"

function timer:__init()
	self.__once = true
	self.__type = timer_type.real_time	
end

function timer:once(is_once)
	self.__once = is_once
	return self
end

function timer:setCallback(callback)
	if get_real_function_by_name(callback) then
		self.__callback = callback
	end
	return self
end

function timer:setCallbackData(data)
	self.__callbackData = data
	return self
end

function timer:isOk()
	return not ( not self.__callback )
end

function timer:__save()
	-- xs_stor.set("timers_last_id", get_max_id())
	avo.save("timers_last_id", get_max_id())
	local trigger_data = {
		cb = self.__callback,
		cbd = self.__callbackData,
		type = self.__type,
		int = ""..self.__interval,		--save as string due big value
		when = ""..self.__trigger_time,	--save as string due big value
		once = self.__once
	}
	-- xs_stor.set("timers_timer_"..self.id, trigger_data)
	avo.save("timers_timer_"..self.id, trigger_data)
end

function timer:__run()
	if self.__trigger_time then
		self.id = get_new_id()
		timers_holder[self.id] = self
		self:__save()
		--rebuild tables
		trigger_timer()
	end
end

function timer:runGame(seconds)
	if seconds and self:isOk() then
		self.__type = timer_type.game_time
		self.__interval = seconds
		self.__trigger_time = game.time() + seconds
		dlog("timer:runGame(seconds) game.time() [%s]", game.time())
		dlog("timer:runGame(seconds) [%s]", self.__trigger_time)
		self:__run()
	end
	return self
end

function timer:runReal(milliseconds)
	if milliseconds and self:isOk() then
		self.__type = timer_type.real_time
		self.__interval = milliseconds
		self.__trigger_time = time_global() + milliseconds
		self:__run()
	end
	return self
end

function timer:stop()

	timers_holder[self.id] = nil
	avo.save("timers_timer_"..self.id)
	avo.save("timers_last_id", get_max_id())

	return self
end

function timer:rearm()

	if self.id then
		self:stop()
	end
	
	if self.__type == timer_type.real_time then
		self:runReal(self.__interval)
	else
		self:runGame(self.__interval)
	end
	
	return self
end

function timer:trigger()
	if not self:isOk() then
		return
	end
	
	local fn = get_real_function_by_name(self.__callback)
	if fn then
		fn(self.__callbackData, self)	-- pass timer object to manipulate with it inside callback
	end
	
	return self
end